<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=width-device, initial-scale=1.0">
    <title>Cut & Fill Analysis - EngineRoom</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js'></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script src="{{ url_for('static', filename='js/core.js') }}"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/adam-chat-widget.css') }}">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header Styles - Light Mode Consistent */
        .site-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding: 16px 24px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 2000;
            height: 60px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .header-back-btn {
            background: rgba(0, 0, 0, 0.05);
            color: #1a202c;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header-back-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #1a202c;
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .header-title {
            color: #1a202c;
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0;
        }

        .header-subtitle {
            color: #4a5568;
            font-size: 0.9rem;
            font-weight: 400;
            margin: 2px 0 0 0;
        }

        /* Engineering Flow Progress */
        .engineering-flow-progress {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            padding: 12px 24px;
            z-index: 1999;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .flow-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            width: 100%;
        }

        .project-info-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-right: 120px;
            flex-shrink: 0;
        }

        .project-name {
            font-size: 16px;
            font-weight: 600;
            color: #1a202c;
            margin-bottom: 2px;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            letter-spacing: -0.02em;
        }

        .project-address {
            font-size: 13px;
            color: #64748b;
            font-weight: 400;
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .flow-steps-container {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .flow-step {
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
        }

        .step-indicator {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .flow-step.active .step-indicator {
            background: #547bf7;
            color: white;
            box-shadow: 0 0 0 4px rgba(84, 123, 247, 0.2);
        }

        .flow-step.completed .step-indicator {
            background: #10b981;
            color: white;
        }

        .step-number {
            font-size: 14px;
            font-weight: 600;
            display: block;
        }

        .step-check {
            font-size: 14px;
            font-weight: 600;
            display: none;
        }

        .flow-step.completed .step-number {
            display: none;
        }

        .flow-step.completed .step-check {
            display: block;
        }

        .step-content {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .step-title {
            font-size: 14px;
            font-weight: 600;
            color: #1a202c;
            white-space: nowrap;
        }

        .step-subtitle {
            font-size: 12px;
            color: #64748b;
            white-space: nowrap;
        }

        .flow-step.active .step-title {
            color: #547bf7;
        }

        .flow-step.completed .step-title {
            color: #10b981;
        }

        .flow-connector {
            width: 60px;
            height: 2px;
            background: #e2e8f0;
            margin: 0 16px;
            position: relative;
            transition: all 0.3s ease;
        }

        .flow-step.completed + .flow-connector {
            background: #10b981;
        }

        .flow-step.active + .flow-connector {
            background: linear-gradient(90deg, #10b981 0%, #e2e8f0 50%, #e2e8f0 100%);
        }

        /* Clickable flow steps */
        .flow-step.clickable {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .flow-step.clickable:hover {
            transform: translateY(-2px);
        }

        .flow-step.clickable:hover .step-indicator {
            box-shadow: 0 4px 12px rgba(84, 123, 247, 0.3);
        }

        .flow-step.clickable:hover .step-title {
            color: #547bf7;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-cta-btn {
            background: linear-gradient(135deg, #547bf7 0%, #4a6bda 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .header-cta-btn:hover {
            background: linear-gradient(135deg, #6287ff 0%, #5575e8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(84, 123, 247, 0.3);
            color: white;
            text-decoration: none;
        }

        /* Main Content */
        .main-content {
            position: absolute;
            top: 116px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
        }

        /* Terrain Canvas Container */
        .terrain-canvas-container {
            flex: 1;
            position: relative;
            background: #181c22;
        }

        /* Terrain Canvas */
        .terrain-canvas {
            width: 100%;
            height: 100%;
            background: #181c22;
            position: relative;
            z-index: 2;
        }

        /* Map Overlay */
        .map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            border-radius: 0;
            pointer-events: none; /* Allow terrain interaction underneath */
            opacity: 0.7;
            mix-blend-mode: multiply; /* Blend with terrain below */
        }

        .map-overlay.visible {
            display: block !important;
            visibility: visible !important;
        }

        .map-overlay .mapboxgl-canvas {
            border-radius: 0;
            width: 100% !important;
            height: 100% !important;
        }

        .map-overlay .mapboxgl-map {
            width: 100% !important;
            height: 100% !important;
        }

        /* Hide Mapbox attribution in overlay */
        .map-overlay .mapboxgl-ctrl-logo,
        .map-overlay .mapboxgl-ctrl-attrib,
        .map-overlay .mapboxgl-ctrl-group,
        .map-overlay .mapboxgl-ctrl {
            display: none !important;
        }

        /* Control Panel */
        .terrain-panel {
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(0, 0, 0, 0.1);
            padding: 24px;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .panel-header {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .panel-title {
            color: #1a202c;
            font-size: 1.1rem;
            font-weight: 600;
            margin: 0 0 8px 0;
        }

        .panel-subtitle {
            color: #4a5568;
            font-size: 0.9rem;
            margin: 0;
        }

        .control-section {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
        }

        .section-title {
            color: #1a202c;
            font-size: 0.95rem;
            font-weight: 600;
            margin: 0 0 12px 0;
        }

        /* View Controls */
        .view-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .control-btn {
            background: linear-gradient(135deg, #547bf7 0%, #4a6bda 100%);
            color: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 56px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #6287ff 0%, #5575e8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(84, 123, 247, 0.3);
        }

        .control-btn:disabled {
            background: rgba(116, 139, 191, 0.4);
            color: rgba(255, 255, 255, 0.7);
            cursor: not-allowed;
            transform: none;
        }

        .loading-spinner {
            display: none;
            text-align: center;
            color: #4a5568;
            padding: 20px;
        }

        .loading-spinner.active {
            display: block;
        }

        .site-info {
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .site-info-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .site-info-item:last-child {
            border-bottom: none;
        }

        .site-info-label {
            color: #4a5568;
            font-size: 0.85rem;
        }

        .site-info-value {
            color: #1a202c;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .error-message {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            color: #ff6b6b;
            font-size: 0.9rem;
            margin-bottom: 16px;
        }

        .success-message {
            background: rgba(85, 182, 133, 0.1);
            border: 1px solid rgba(85, 182, 133, 0.3);
            border-radius: 8px;
            padding: 12px;
            color: #55B685;
            font-size: 0.9rem;
            margin-bottom: 16px;
        }

        /* Progress Tracking Styles */
        .progress-container {
            background: rgba(248, 250, 252, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .progress-header {
            margin-bottom: 16px;
        }

        .progress-title {
            color: #1a202c;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .progress-status {
            color: #4a5568;
            font-size: 0.85rem;
        }

        .progress-bar-container {
            position: relative;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            height: 8px;
            margin-bottom: 16px;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, #547bf7 0%, #51cf66 100%);
            height: 100%;
            width: 0%;
            border-radius: 8px;
            transition: width 0.3s ease;
        }

        .progress-percent {
            position: absolute;
            top: -20px;
            right: 0;
            color: #1a202c;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .progress-steps {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .progress-step {
            display: flex;
            align-items: center;
            color: #64748b;
            font-size: 0.8rem;
            transition: color 0.3s ease;
            padding: 4px 0;
        }

        .progress-step.active {
            color: #547bf7;
            font-weight: 500;
        }

        .progress-step.completed {
            color: #51cf66;
        }

        .progress-step.error {
            color: #ff6b6b;
        }

        /* Earthworks Controls */
        .platform-controls, .ffl-controls {
            margin-bottom: 16px;
        }

        .control-label {
            display: block;
            color: #1a202c;
            font-size: 0.85rem;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .input-row {
            display: flex;
            gap: 8px;
        }

        .input-row input {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            padding: 8px 12px;
            color: #1a202c;
            font-size: 0.85rem;
        }

        .input-row input:focus {
            outline: none;
            border-color: #547bf7;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 2px rgba(84, 123, 247, 0.2);
        }

        .ffl-options {
            display: flex;
            gap: 12px;
            margin-bottom: 8px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #1a202c;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .radio-option input[type="radio"] {
            margin: 0;
        }

        #manualFFL {
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            padding: 8px 12px;
            color: #1a202c;
            font-size: 0.85rem;
        }

        #manualFFL:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #manualFFL:focus {
            outline: none;
            border-color: #547bf7;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 2px rgba(84, 123, 247, 0.2);
        }

        /* Platform Rotation Controls */
        #platformRotation {
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            height: 8px;
            outline: none;
            cursor: pointer;
        }

        #platformRotation::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #547bf7;
            cursor: pointer;
            border: 2px solid #ffffff;
        }

        #platformRotation::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #547bf7;
            cursor: pointer;
            border: 2px solid #ffffff;
        }

        #platformRotationValue {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            padding: 8px 12px;
            color: #1a202c;
            font-size: 0.85rem;
            text-align: center;
        }

        #platformRotationValue:focus {
            outline: none;
            border-color: #547bf7;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 2px rgba(84, 123, 247, 0.2);
        }

        /* Results Display */
        .results-grid {
            display: grid;
            gap: 12px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 8px;
        }

        .result-label {
            color: #4a5568;
            font-size: 0.85rem;
        }

        .result-value {
            color: #1a202c;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .result-value.positive {
            color: #cd853f;
        }

        .result-value.negative {
            color: #4a6fa5;
        }

        /* Map Overlay Settings */
        .map-overlay-settings {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .overlay-style-select {
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            padding: 8px 12px;
            color: #1a202c;
            font-size: 0.85rem;
            margin-bottom: 12px;
        }

        .overlay-style-select:focus {
            outline: none;
            border-color: #547bf7;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 2px rgba(84, 123, 247, 0.2);
        }

        .overlay-style-select option {
            background: #ffffff;
            color: #1a202c;
        }

        .opacity-value {
            color: #4a5568;
            font-size: 0.85rem;
            min-width: 40px;
            text-align: right;
        }

        #overlayOpacity {
            background: rgba(248, 250, 252, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 6px;
            height: 8px;
            outline: none;
            cursor: pointer;
            flex: 1;
            margin-right: 8px;
        }

        #overlayOpacity::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #547bf7;
            cursor: pointer;
            border: 2px solid #ffffff;
        }

        #overlayOpacity::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #547bf7;
            cursor: pointer;
            border: 2px solid #ffffff;
        }

        /* Toggle Switch Styles */
        .toggle-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(116, 139, 191, 0.3);
            transition: 0.3s;
            border-radius: 24px;
            border: 1px solid rgba(0, 0, 0, 0.15);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: #ffffff;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #547bf7;
            border-color: #547bf7;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .engineering-flow-progress {
                padding: 12px 16px;
                height: 70px;
            }

            .flow-container {
                overflow-x: auto;
                padding: 8px 0;
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .project-info-section {
                margin-right: 0;
                margin-bottom: 8px;
            }

            .project-name {
                font-size: 14px;
            }

            .project-address {
                font-size: 12px;
            }

            .flow-steps-container {
                overflow-x: auto;
                width: 100%;
            }

            .step-content {
                display: none;
            }

            .flow-connector {
                width: 40px;
                margin: 0 8px;
            }

            .main-content {
                flex-direction: column;
                top: 130px;
            }

            .terrain-panel {
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }
        }

        .message {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            display: none;
        }

        .location-error {
            text-align: left;
        }

        .location-error h4 {
            margin: 0 0 10px 0;
            color: #721c24;
        }

        .location-error .error-details {
            background: rgba(0,0,0,0.05);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .location-error .error-details p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <!-- Site Header -->
    <div class="site-header">
        <div class="header-left">
            <a href="{% if project_data and project_data.get('id') %}/project/{{ project_data.get('id') }}{% else %}/dashboard{% endif %}" class="header-back-btn">
                ← Project Overview
            </a>
            <div class="header-title-section">
                <h1 class="header-title">Cut & Fill Analysis</h1>
                <p class="header-subtitle">LiDAR elevation data and earthworks visualisation</p>
            </div>
        </div>
        <div class="header-right">
            <a href="/site-developer{% if project_data and project_data.get('id') %}?project_id={{ project_data.get('id') }}{% endif %}" class="header-cta-btn">FormLab</a>
        </div>
    </div>

    <!-- Engineering Flow Progress -->
    <div class="engineering-flow-progress">
        <div class="flow-container">
            <!-- Project Information -->
            <div class="project-info-section">
                {% if project_data and project_data.get('name') %}
                <div class="project-name">{{ project_data.get('name', 'Current Project') }}</div>
                {% set address = project_data.get('address', '') %}
                {% if address %}
                    {% if address|length > 45 %}
                    <div class="project-address" title="{{ address }}">{{ address[:42] }}...</div>
                    {% else %}
                    <div class="project-address">{{ address }}</div>
                    {% endif %}
                {% else %}
                <div class="project-address">No address available</div>
                {% endif %}
                {% elif site_data and site_data.get('address') %}
                <div class="project-name">{{ site_data.get('project_name', 'Current Project') }}</div>
                {% set address = site_data.get('address', '') %}
                {% if address %}
                    {% if address|length > 45 %}
                    <div class="project-address" title="{{ address }}">{{ address[:42] }}...</div>
                    {% else %}
                    <div class="project-address">{{ address }}</div>
                    {% endif %}
                {% else %}
                <div class="project-address">No address available</div>
                {% endif %}
                {% else %}
                <div class="project-name">Current Project</div>
                <div class="project-address">No address available</div>
                {% endif %}
            </div>

            <div class="flow-steps-container">
                <div class="flow-step completed clickable" onclick="navigateToStep(1)">
                    <div class="step-indicator">
                        <div class="step-number">1</div>
                        <div class="step-check">✓</div>
                    </div>
                    <div class="step-content">
                        <div class="step-title">Site Inspector</div>
                        <div class="step-subtitle">Define site boundaries</div>
                    </div>
                </div>

                <div class="flow-connector completed"></div>

                <div class="flow-step active clickable" onclick="navigateToStep(2)">
                    <div class="step-indicator">
                        <div class="step-number">2</div>
                        <div class="step-check">✓</div>
                    </div>
                    <div class="step-content">
                        <div class="step-title">Cut & Fill Analysis</div>
                        <div class="step-subtitle">Analyse site topography</div>
                    </div>
                </div>

                <div class="flow-connector"></div>

                <div class="flow-step clickable" onclick="navigateToStep(3)">
                    <div class="step-indicator">
                        <div class="step-number">3</div>
                        <div class="step-check">✓</div>
                    </div>
                    <div class="step-content">
                        <div class="step-title">FormLab</div>
                        <div class="step-subtitle">AI development assistant</div>
                    </div>
                </div>

                <div class="flow-connector"></div>

                <div class="flow-step clickable" onclick="navigateToStep(4)">
                    <div class="step-indicator">
                        <div class="step-number">4</div>
                        <div class="step-check">✓</div>
                    </div>
                    <div class="step-content">
                        <div class="step-title">Structure Designer</div>
                        <div class="step-subtitle">Design your building</div>
                    </div>
                </div>

                <div class="flow-connector"></div>

                <div class="flow-step clickable" onclick="navigateToStep(5)">
                    <div class="step-indicator">
                        <div class="step-number">5</div>
                        <div class="step-check">✓</div>
                    </div>
                    <div class="step-content">
                        <div class="step-title">Structure Analyser</div>
                        <div class="step-subtitle">Validate structural integrity</div>
                    </div>
                </div></div>
            </div>
        </div>
    </div>

    <div class="main-content">
        <!-- Terrain Canvas with Map Overlay -->
        <div class="terrain-canvas-container">
            <div id="terrainCanvas" class="terrain-canvas"></div>
            <div id="mapOverlay" class="map-overlay" style="display: none;"></div>
        </div>

        <!-- Control Panel -->
        <div class="terrain-panel">
            <div class="panel-header">
                <h2 class="panel-title">Cut & Fill Controls</h2>
                <p class="panel-subtitle">Generate and visualise 3D terrain data</p>
            </div>



            <!-- Generate Terrain Button (shown when no terrain data available) -->
            <div id="generateTerrainSection" class="control-section">
                <div class="section-title">Generate 3D Terrain</div>
                <p style="color: #4a5568; font-size: 0.85rem; margin-bottom: 16px;">
                    Generate terrain elevation data from the project address or site boundary.
                </p>
                <button id="generateTerrainBtn" class="control-btn" style="width: 100%; background: linear-gradient(135deg, #547bf7 0%, #4a6bda 100%);">
                    Generate 3D Terrain
                </button>
            </div>

            <!-- Error Message -->
            <div id="errorMessage" class="error-message" style="display: none;"></div>

            <!-- Success Message -->
            <div id="successMessage" class="success-message" style="display: none;"></div>

            <!-- Progress Tracking -->
            <div id="progressContainer" class="progress-container" style="display: none;">
                <div class="progress-header">
                    <div class="progress-title">Generating 3D Terrain</div>
                    <div id="progressStatus" class="progress-status">Initializing...</div>
                </div>
                <div class="progress-bar-container">
                    <div id="progressBar" class="progress-bar"></div>
                    <div id="progressPercent" class="progress-percent">0%</div>
                </div>
                <div id="progressSteps" class="progress-steps">
                    <div class="progress-step" data-step="1">Geocoding coordinates</div>
                    <div class="progress-step" data-step="2">Identifying city region</div>
                    <div class="progress-step" data-step="3">Retrieving property boundary</div>
                    <div class="progress-step" data-step="4">Finding DEM tiles</div>
                    <div class="progress-step" data-step="5">Searching elevation data</div>
                    <div class="progress-step" data-step="6">Processing terrain data</div>
                    <div class="progress-step" data-step="7">Creating visualisation</div>
                </div>
            </div>

            <!-- Loading Spinner (fallback) -->
            <div id="loadingSpinner" class="loading-spinner">
                <div>Loading terrain data...</div>
                <div style="font-size: 0.8rem; margin-top: 8px;">This may take a few moments</div>
            </div>

            <!-- View Controls moved up since generation is automatic -->
            <div class="control-section">
                <div class="section-title">View Controls</div>
                <div class="view-controls">
                    <button id="resetViewBtn" class="control-btn" disabled>
                        Reset
                    </button>
                    <button id="topViewBtn" class="control-btn" disabled>
                        Top
                    </button>
                    <button id="sideViewBtn" class="control-btn" disabled>
                        Side
                    </button>
                    <button id="perspectiveViewBtn" class="control-btn" disabled>
                        3D
                    </button>
                </div>
            </div>



            <!-- Visualisation Settings -->
            <div class="control-section">
                <div class="section-title">Visualisation Settings</div>

                <div class="platform-controls">
                    <label class="control-label">Terrain Opacity</label>
                    <div class="input-row">
                        <input type="range" id="terrainOpacity" min="0.1" max="1" value="1" step="0.1" style="flex: 2;">
                        <span id="terrainOpacityValue" class="opacity-value">1.0</span>
                    </div>
                </div>

                <div class="platform-controls" style="display: none;">
                    <label class="control-label">Vertical Exaggeration</label>
                    <div class="input-row">
                        <input type="range" id="verticalScale" min="0.5" max="5" value="2.5" step="0.1" style="flex: 2;">
                        <span id="verticalScaleValue" class="opacity-value">2.5x</span>
                    </div>
                </div>

                <div class="platform-controls">
                    <label class="control-label">Colour Scheme</label>
                    <select id="colorSchemeSelect" class="overlay-style-select">
                        <option value="terrain">Terrain (Blue-White)</option>
                        <option value="viridis">Viridis</option>
                    </select>
                </div>

                <div class="toggle-control" style="display: none;">
                    <label class="control-label">Show Grid</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="gridToggle">
                        <span class="toggle-slider"></span>
                    </div>
                </div>

                <div class="toggle-control" style="display: none;">
                    <label class="control-label">Auto Rotate</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="autoRotateToggle">
                        <span class="toggle-slider"></span>
                    </div>
                </div>
            </div>

            <!-- Earthworks Controls -->
            <div class="control-section">
                <div class="section-title">Earthworks Analysis</div>
                <button id="loadBuildableAreaBtn" class="control-btn" disabled style="width: 100%;">
                    No Buildable Area Available
                </button>

                <!-- Basic Earthworks Calculation -->
                <div style="margin-top: 15px;">
                    <button id="calculateEarthworksBtn" class="control-btn" disabled style="width: 100%;">
                        Calculate Earthworks
                    </button>
                    <button id="clearPlatformBtn" class="control-btn" disabled style="width: 100%; margin-top: 8px; background: #dc3545;">
                        Clear Platform
                    </button>
                    <button id="togglePlatformMoveBtn" class="control-btn" disabled style="width: 100%; margin-top: 8px; background: #6c757d;">
                        Enable Platform Movement
                    </button>
                </div>

                <!-- FFL Controls -->
                <div class="ffl-controls" style="margin-top: 15px;">
                    <label class="control-label">Finished Floor Level (FFL)</label>
                    <div class="ffl-options">
                        <div class="radio-option">
                            <input type="radio" name="fflMode" value="optimize" id="optimizeFFL" checked>
                            <label for="optimizeFFL">Optimize</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" name="fflMode" value="manual" id="manualFFL">
                            <label for="manualFFL">Manual</label>
                        </div>
                    </div>
                    <input type="number" id="manualFFL" placeholder="FFL (m)" disabled step="0.1" style="width: 100%; margin-top: 8px;">
                </div>

                <!-- Building Platform Container -->
                <div class="platform-container" style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                    <label class="control-label" style="font-weight: bold;">Building Platform</label>
                    <button id="loadPlatformBtn" class="control-btn" disabled style="width: 100%; margin-top: 8px;">
                        Load Structure Polygon
                    </button>

                    <!-- Platform Controls (hidden initially) -->
                    <div id="platformControls" style="display: none; margin-top: 10px;">
                        <label class="control-label">Platform Dimensions (m)</label>
                        <div class="input-row">
                            <input type="number" id="platformWidth" placeholder="Width" value="10" min="5" max="50" step="0.5">
                            <input type="number" id="platformLength" placeholder="Length" value="10" min="5" max="50" step="0.5">
                        </div>

                        <label class="control-label" style="margin-top: 8px;">Platform Position</label>
                        <div class="input-row">
                            <input type="number" id="platformCenterX" placeholder="Center X" value="0" step="0.1" style="flex: 1;">
                            <input type="number" id="platformCenterY" placeholder="Center Y" value="0" step="0.1" style="flex: 1; margin-left: 8px;">
                        </div>

                        <label class="control-label" style="margin-top: 8px;">Platform Rotation</label>
                        <div class="input-row">
                            <input type="range" id="platformRotation" min="0" max="360" value="0" step="5" style="flex: 2;">
                            <input type="number" id="platformRotationValue" value="0" min="0" max="360" step="5" style="flex: 1; margin-left: 8px;">
                        </div>

                        <div class="input-row" style="margin-top: 10px;">
                            <button id="resetPlatformBtn" class="control-btn" style="background: #6c757d; flex: 1;">Reset</button>
                            <button id="confirmPlatformBtn" class="control-btn" style="flex: 2; margin-left: 8px;">Calculate Earthworks</button>
                        </div>
                    </div>
                </div>

                <!-- Platform Definition (legacy - keep for compatibility) -->
                <div class="platform-controls" style="display: none;">
                    <label class="control-label">Platform Size (m)</label>
                    <div class="input-row">
                        <input type="number" id="platformWidthLegacy" placeholder="Width" value="10" min="5" max="50" step="1">
                        <input type="number" id="platformLengthLegacy" placeholder="Length" value="10" min="5" max="50" step="1">
                    </div>
                </div>

                <!-- Platform Rotation (legacy - keep for compatibility) -->
                <div class="platform-controls" style="display: none;">
                    <label class="control-label">Platform Rotation</label>
                    <div class="input-row">
                        <input type="range" id="platformRotationLegacy" min="0" max="360" value="0" step="5" style="flex: 2;">
                        <input type="number" id="platformRotationValueLegacy" value="0" min="0" max="360" step="5" style="flex: 1; margin-left: 8px;">
                    </div>
                </div>
            </div>

            <!-- Earthworks Results -->
            <div id="earthworksResults" class="control-section" style="display: none;">
                <div class="section-title">Earthworks Results</div>
                <div class="results-grid">
                    <div class="result-item">
                        <span class="result-label">Cut Volume:</span>
                        <span id="cutVolume" class="result-value">0 m³</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">Fill Volume:</span>
                        <span id="fillVolume" class="result-value">0 m³</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">Net Earthwork:</span>
                        <span id="netEarthwork" class="result-value">0 m³</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">Platform Area:</span>
                        <span id="platformArea" class="result-value">0 m²</span>
                    </div>
                    <div class="result-item">
                        <span class="result-label">Final FFL:</span>
                        <span id="finalFFL" class="result-value">0 m</span>
                    </div>
                </div>

                <!-- Engineering Notes -->
                <div id="engineeringNotes" class="engineering-section" style="display: none;">
                    <!-- Notes will be populated by JavaScript -->
                </div>
            </div>



            <!-- Map Overlay Controls -->




        </div>
    </div>

    <script>
        // Cut & Fill Analysis JavaScript
        class TerrainViewer {
            constructor() {
                this.terrainData = null;
                this.plot = null;
                this.siteData = {{ site_data_json|safe if site_data_json else '{}' }};
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.currentPlatformCenter = { x: 0.5, y: 0.5 }; // Center of terrain (0-1 range)
                this.currentPlatformRotation = 0; // Rotation in degrees
                this.platformMovementEnabled = false; // Toggle for platform movement mode
                this.autoRotateInterval = null; // Auto-rotate interval

                // Map overlay functionality
                this.mapOverlay = null;
                this.mapOverlayVisible = false;
                this.mapboxToken = null;
                this.terrainBounds = null; // Store terrain bounds

                // Progress tracking
                this.progressSteps = [
                    { id: 1, name: 'Geocoding coordinates', weight: 10 },
                    { id: 2, name: 'Identifying city region', weight: 15 },
                    { id: 3, name: 'Retrieving property boundary', weight: 20 },
                    { id: 4, name: 'Finding DEM tiles', weight: 25 },
                    { id: 5, name: 'Searching elevation data', weight: 40 },
                    { id: 6, name: 'Processing terrain data', weight: 50 },
                    { id: 7, name: 'Creating visualisation', weight: 70 }
                ];
                this.currentProgress = 0;

                // Structure platform data
                this.structurePlatformData = null;
                this.currentPlatformCoords = null;
                this.earthworksData = null; // To store calculated earthworks

                this.initializeEventListeners();
                this.showWelcomeMessage();

            // Auto-load site data and generate terrain on initialization
                this.autoInitializeTerrainGeneration();

            // Listen for site boundary events if available
                if (window.eventBus) {
                    window.eventBus.on('site-boundary-created', (data) => {
                        console.log('[TerrainViewer] Site boundary created:', data);
                        if (data.coordinates) {
                            // Update site data with new boundary
                            this.siteData = this.siteData || {};
                            this.siteData.coordinates = data.coordinates;
                            this.siteData.area_m2 = data.area;

                            // Store terrain bounds for synchronized rendering
                            if (data.terrainBounds) {
                                this.terrainBounds = data.terrainBounds;
                                console.log('[TerrainViewer] Stored terrain bounds:', this.terrainBounds);
                            }

                            console.log('[TerrainViewer] Updated site data from boundary event');

                            // Update map overlay if visible
                            if (this.mapOverlayVisible) {

                            }
                        }
                    });

                    window.eventBus.on('site-boundary-loaded', (data) => {
                        console.log('[TerrainViewer] Site boundary loaded:', data);
                        if (data.coordinates) {
                            // Update site data with loaded boundary
                            this.siteData = this.siteData || {};
                            this.siteData.coordinates = data.coordinates;
                            this.siteData.area_m2 = data.area;

                            // Calculate terrain bounds from loaded coordinates

                            console.log('[TerrainViewer] Calculated terrain bounds from loaded boundary:', this.terrainBounds);

                            console.log('[TerrainViewer] Updated site data from loaded boundary');
                        }
                    });

                    window.eventBus.on('site-boundary-deleted', () => {
                        console.log('[TerrainViewer] Site boundary deleted');
                        if (this.siteData) {
                            delete this.siteData.coordinates;
                            delete this.siteData.area_m2;
                            this.terrainBounds = null;
                            console.log('[TerrainViewer] Cleared site boundary from site data');
                        }
                    });
                }
            }

        async autoInitializeTerrainGeneration() {
                try {
                    // Always show the generate terrain button initially
                    this.showGenerateTerrainButton();

                    // Check if we have site data already available from the template
                    if (this.siteData && (this.siteData.coordinates?.length > 0 || this.siteData.buildable_area?.coordinates?.length > 0)) {
                        console.log('[TerrainViewer] Site data already available, but showing generate button for user control');

                        // Log what data we have available
                        const availableData = [];
                        if (this.siteData.coordinates) availableData.push('site boundary');
                        if (this.siteData.buildable_area?.coordinates) availableData.push('buildable area');
                        if (this.siteData.structure_placement?.coordinates) availableData.push('structure placement');
                        if (this.siteData.floorplan_data?.boundaries) availableData.push('floor plan');

                        console.log(`[TerrainViewer] Available data layers: ${availableData.join(', ')}`);

                        // Don't auto-generate, let user click the button
                        this.showMessage(`Ready to generate terrain with: ${availableData.join(', ')}`, 'info');
                    } else {
                        console.log('[TerrainViewer] No site data available for auto-initialization');

                        // Try to load from project if we have a project ID
                        const urlParams = new URLSearchParams(window.location.search);
                        const projectId = urlParams.get('project') || urlParams.get('project_id');

                        if (projectId) {
                            console.log('[TerrainViewer] Attempting to load site data from project:', projectId);
                            try {
                                const response = await apiClient.post('/load-site-data', { project_id: projectId });
                                if (response.success && response.site_data) {
                                    this.siteData = response.site_data;

                                    // Log what data was loaded
                                    const loadedData = [];
                                    if (response.site_data.coordinates) loadedData.push('site boundary');
                                    if (response.site_data.buildable_area?.coordinates) loadedData.push('buildable area');
                                    if (response.site_data.structure_placement?.coordinates) loadedData.push('structure placement');
                                    if (response.site_data.floorplan_data?.boundaries) loadedData.push('floor plan');

                                    console.log(`[TerrainViewer] Loaded data layers: ${loadedData.join(', ')}`);
                                    
                                    if (loadedData.length > 0) {
                                        this.showMessage(`Site data loaded. Ready to generate terrain with: ${loadedData.join(', ')}`, 'success');
                                    } else {
                                        this.showMessage('Site data loaded, but no boundary coordinates found. Terrain can still be generated from project address.', 'info');
                                    }
                                } else {
                                    console.log('[TerrainViewer] No site data found in project');
                                    this.showMessage('No site data found. Terrain can be generated from project address.', 'info');
                                }
                            } catch (error) {
                                console.error('[TerrainViewer] Error loading site data from project:', error);
                                this.showMessage('Error loading site data, but terrain can still be generated from project address.', 'warning');
                            }
                        }
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Auto-initialization failed:', error);
                    this.showMessage('Initialization error, but terrain generation is still available.', 'warning');
                }
            }

            showGenerateTerrainButton() {
                // Always show the generate terrain button
                document.getElementById('generateTerrainSection').style.display = 'block';
                
                // Check if we have data to work with
                const hasProjectAddress = this.siteData && (this.siteData.address || this.siteData.project_address);
                const hasCoordinates = (this.siteData?.coordinates?.length > 0) || 
                                     (this.siteData?.buildable_area?.coordinates?.length > 0);

                if (hasCoordinates) {
                    console.log('[TerrainViewer] Generate terrain button shown with coordinate data available');
                } else if (hasProjectAddress) {
                    console.log('[TerrainViewer] Generate terrain button shown with project address available');
                } else {
                    console.log('[TerrainViewer] Generate terrain button shown - will need site data');
                }
            }

            showMessage(message, type = 'info') {
                console.log(`[TerrainViewer] ${type.toUpperCase()}: ${message}`);
                // You can add UI message display here if needed
            }

            async generateTerrainFromAddress() {
                if (!this.siteData || (!this.siteData.address && !this.siteData.project_address)) {
                    this.showError('No project address available for terrain generation');
                    return;
                }

                try {
                    // Hide the generate button and show progress
                    document.getElementById('generateTerrainSection').style.display = 'none';
                    this.showLoading(true);

                    // Use the address to geocode and create site boundary
                    const address = this.siteData.address || this.siteData.project_address;
                    console.log('[TerrainViewer] Generating terrain from address:', address);

                    // First, geocode the address to get coordinates
                    const geocodeResponse = await fetch('/api/generate-terrain-from-address', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            address: address,
                            project_id: this.siteData.project_id
                        })
                    });

                    const geocodeResult = await geocodeResponse.json();

                    if (!geocodeResult.success) {
                        this.showError(geocodeResult.error || 'Failed to geocode address');
                        document.getElementById('generateTerrainSection').style.display = 'block';
                        this.showLoading(false);
                        return;
                    }

                    // Update site data with geocoded coordinates
                    this.siteData = geocodeResult.site_data;

                    // Now generate terrain using the geocoded site data
                    await this.generateTerrain();

                } catch (error) {
                    this.showError(`Error generating terrain: ${error.message}`);
                    console.error('[TerrainViewer] Terrain generation from address error:', error);
                    // Show the generate button again
                    document.getElementById('generateTerrainSection').style.display = 'block';
                    this.showLoading(false);
                }
            }

        async loadSiteData() {
                try {
                    this.showLoading(true);
                    this.clearMessages();
                    this.updateProgressStatus('Loading site data...');

                    // Get project ID from URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const projectId = urlParams.get('project_id') || urlParams.get('project');

                    console.log('[TerrainViewer] Loading site data for project:', projectId);

                    if (!projectId) {
                        this.showError('No project ID found in URL');
                        this.showLoading(false);
                        return false;
                    }

                    const response = await fetch('/api/load-site-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            project_id: projectId
                        })
                    });

                    console.log('[TerrainViewer] Site data response status:', response.status);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('[TerrainViewer] Site data response:', result);

                    if (result.success) {
                        this.siteData = result.site_data;

                        // Validate site data structure
                        if (!this.siteData || !this.siteData.coordinates || this.siteData.coordinates.length === 0) {
                            this.showError('Site data loaded but contains no coordinates. Please draw a site boundary first.');
                            return false;
                        }

                        this.info('Site data loaded successfully:', this.siteData);

                        // Enable terrain generation button
                        document.getElementById('generateTerrainBtn').disabled = false;

                        return true;

                    } else {
                    this.showError(result.error || 'Failed to load site data', result);
                    console.error('[TerrainViewer] Site data loading failed:', result.error);
                    return false;
                }

            } catch (error) {
                this.showError(`Error loading site data: ${error.message}`);
                console.error('[TerrainViewer] Site data loading error:', error);
                return false;
            } finally {
                this.showLoading(false);
            }

            return false;
        }

            updateStatus(message, isError = false) {
                try {
                    // Use the correct progress status element ID
                    const statusElement = document.getElementById('progressStatus');
                    if (statusElement && message) {
                        statusElement.textContent = message;
                    } else if (message) {
                        console.log('[TerrainViewer] Status update (no DOM element):', message);
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error updating status:', error);
                }
            }

            updateProgress(percentage, message) {
                try {
                    // Use the correct progress bar element IDs
                    const progressBar = document.getElementById('progressBar');
                    const progressPercent = document.getElementById('progressPercent');

                    if (progressBar) {
                        progressBar.style.width = `${percentage}%`;
                    }

                    if (progressPercent) {
                        progressPercent.textContent = `${Math.round(percentage)}%`;
                    }

                    if (!progressBar && !progressPercent) {
                        console.log('[TerrainViewer] Progress update (no DOM elements):', `${percentage}% - ${message}`);
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error updating progress:', error);
                }
            }

            showError(errorMessage) {
                try {
                    console.error('[TerrainViewer] Terrain generation error:', errorMessage);
                    
                    const errorElement = document.getElementById('errorMessage');
                    if (errorElement) {
                        errorElement.textContent = errorMessage || 'Unknown error occurred';
                        errorElement.style.display = 'block';
                    }

                    this.updateProgressStatus(errorMessage || 'Error occurred');
                    this.updateProgress(1, 'error');
                    this.showLoading(false);

                    // Show generate button again
                    const generateSection = document.getElementById('generateTerrainSection');
                    if (generateSection) {
                        generateSection.style.display = 'block';
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error in showError:', error);
                }
            }

            showSuccess(message) {
                try {
                    console.log('[TerrainViewer] Success:', message);
                    
                    const successElement = document.getElementById('successMessage');
                    if (successElement) {
                        successElement.textContent = message || 'Terrain generated successfully';
                        successElement.style.display = 'block';
                    }

                    this.updateProgressStatus(message || 'Complete!');
                    this.updateProgress(7, 'completed');
                    this.updateProgressBar(100);

                    // Hide error messages
                    const errorElement = document.getElementById('errorMessage');
                    if (errorElement) {
                        errorElement.style.display = 'none';
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error in showSuccess:', error);
                }
            }





            initializeEventListeners() {
                // Helper function to safely add event listeners
                const addListener = (id, event, handler) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener(event, handler);
                        console.log(`[TerrainViewer] Added ${event} listener to ${id}`);
                    } else {
                        console.warn(`[TerrainViewer] Element ${id} not found, skipping event listener`);
                    }
                };

                // View controls
                addListener('resetViewBtn', 'click', () => this.resetView());
                addListener('topViewBtn', 'click', () => this.setTopView());
                addListener('sideViewBtn', 'click', () => this.setSideView());
                addListener('perspectiveViewBtn', 'click', () => this.setPerspectiveView());
                addListener('loadBuildableAreaBtn', 'click', () => this.loadBuildableAreaAsPlatform());
                addListener('generateTerrainBtn', 'click', () => this.generateTerrainFromAddress());

                // Earthworks controls
                addListener('calculateEarthworksBtn', 'click', () => this.calculateEarthworks());
                addListener('clearPlatformBtn', 'click', () => this.clearPlatform());
                addListener('togglePlatformMoveBtn', 'click', () => this.togglePlatformMovement());

                // FFL mode radio buttons
                const fflRadios = document.querySelectorAll('input[name="fflMode"]');
                if (fflRadios.length > 0) {
                    fflRadios.forEach(radio => {
                        radio.addEventListener('change', () => this.updateFflMode());
                    });
                    console.log(`[TerrainViewer] Added change listeners to ${fflRadios.length} FFL mode radio buttons`);
                } else {
                    console.warn('[TerrainViewer] FFL mode radio buttons not found');
                }

                // Platform rotation controls
                addListener('platformRotation', 'input', (e) => this.updateRotation(e.target.value));
                addListener('platformRotationValue', 'input', (e) => this.updateRotation(e.target.value));

                // Platform movement toggle
                addListener('togglePlatformMoveBtn', 'click', () => this.togglePlatformMovement());

                // Building Platform controls
                addListener('loadPlatformBtn', 'click', () => {
                    this.loadStructurePlatform();
                });

                addListener('resetPlatformBtn', 'click', () => {
                    this.resetPlatform();
                });

                addListener('confirmPlatformBtn', 'click', () => {
                    this.calculatePlatformEarthworks();
                });

                // Platform position controls
                addListener('platformCenterX', 'input', () => {
                    this.updatePlatformPosition();
                });

                addListener('platformCenterY', 'input', () => {
                    this.updatePlatformPosition();
                });

                // Dimension controls
                ['platformWidth', 'platformLength'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => {
                            this.updatePlatformDimensions();
                        });
                        console.log(`[TerrainViewer] Added input listener to ${id}`);
                    } else {
                        console.warn(`[TerrainViewer] Element ${id} not found for dimension controls`);
                    }
                });

                // Manual FFL input
                addListener('manualFFL', 'input', () => {
                    this.updateEarthworksDisplay();
                });

                // Additional FFL mode radio button handlers
                const fflRadios2 = document.querySelectorAll('input[name="fflMode"]');
                if (fflRadios2.length > 0) {
                    fflRadios2.forEach(radio => {
                        radio.addEventListener('change', () => {
                            const manualFflElement = document.getElementById('manualFFL');
                            const isManualElement = document.querySelector('input[name="fflMode"][value="manual"]');
                            if (manualFflElement && isManualElement) {
                                const isManual = isManualElement.checked;
                                manualFflElement.disabled = !isManual;
                                this.updateEarthworksDisplay();
                            }
                        });
                    });
                }

                console.log('[TerrainViewer] Event listeners initialization completed');
            }



            showWelcomeMessage() {
                const canvas = document.getElementById('terrainCanvas');
                canvas.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #cccccc; text-align: center; flex-direction: column;">
                        <h2 style="margin: 0 0 8px 0; color: #ffffff;">Cut & Fill Analysis</h2>
                        <p style="margin: 0; max-width: 400px;">Click "Generate 3D Terrain" to create a detailed elevation model of your site using LiDAR data.</p>
                    </div>
                `;
            }

            showLoading(show) {
                try {
                    const progressContainer = document.getElementById('progressContainer');
                    const generateSection = document.getElementById('generateTerrainSection');
                    const loadingSpinner = document.getElementById('loadingSpinner');

                    if (show) {
                        if (progressContainer) {
                            progressContainer.style.display = 'block';
                        }
                        if (generateSection) {
                            generateSection.style.display = 'none';
                        }
                        if (loadingSpinner) {
                            loadingSpinner.classList.add('active');
                        }
                    } else {
                        if (progressContainer) {
                            progressContainer.style.display = 'none';
                        }
                        if (generateSection) {
                            generateSection.style.display = 'block';
                        }
                        if (loadingSpinner) {
                            loadingSpinner.classList.remove('active');
                        }
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error in showLoading:', error);
                }
            }

            clearMessages() {
                try {
                    const errorMessage = document.getElementById('errorMessage');
                    const successMessage = document.getElementById('successMessage');

                    if (errorMessage) {
                        errorMessage.style.display = 'none';
                        errorMessage.textContent = '';
                    }
                    if (successMessage) {
                        successMessage.style.display = 'none';
                        successMessage.textContent = '';
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error clearing messages:', error);
                }
            }

            updateProgressStatus(message) {
                try {
                    const statusElement = document.getElementById('progressStatus');
                    if (statusElement && message) {
                        statusElement.textContent = message;
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error updating progress status:', error);
                }
            }

            updateProgressBar(percentage) {
                try {
                    const progressBar = document.getElementById('progressBar');
                    const progressPercent = document.getElementById('progressPercent');

                    if (progressBar) {
                        progressBar.style.width = `${percentage}%`;
                    }
                    if (progressPercent) {
                        progressPercent.textContent = `${Math.round(percentage)}%`;
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error updating progress bar:', error);
                }
            }

            updateProgress(stepNumber, status) {
                try {
                    const progressSteps = document.querySelectorAll('.progress-step');
                    
                    progressSteps.forEach((step, index) => {
                        const stepNum = index + 1;
                        step.classList.remove('active', 'completed', 'error');
                        
                        if (stepNum < stepNumber) {
                            step.classList.add('completed');
                        } else if (stepNum === stepNumber) {
                            if (status === 'error') {
                                step.classList.add('error');
                            } else if (status === 'completed') {
                                step.classList.add('completed');
                            } else {
                                step.classList.add('active');
                            }
                        }
                    });
                } catch (error) {
                    console.error('[TerrainViewer] Error updating progress:', error);
                }
            }

            async generateTerrain() {
                const progressContainer = document.getElementById('progressContainer');
                const progressBar = document.getElementById('progressBar');
                const progressStatus = document.getElementById('progressStatus');

                // Check for site coordinates or buildable area coordinates
                const hasCoordinates = (this.siteData?.coordinates?.length > 0) || 
                                     (this.siteData?.buildable_area?.coordinates?.length > 0);
                
                const hasAddress = this.siteData?.address || this.siteData?.project_address;

                if (!this.siteData || (!hasCoordinates && !hasAddress)) {
                    this.showError('No site data available. Please create site boundary data in Site Inspector first or ensure project has an address.');
                    return;
                }

                try {
                    // Ensure progress container is visible and properly initialized
                    this.showLoading(true);

                    // Force progress container to be visible
                    if (progressContainer) {
                        progressContainer.style.display = 'block';
                        progressContainer.style.visibility = 'visible';
                    }

                    if (progressStatus) {
                        progressStatus.textContent = 'Generating 3D terrain data...';
                    }
                    if (progressBar) {
                        progressBar.style.width = '0%';
                    }

                    console.log('[TerrainViewer] Starting terrain generation with site data:', this.siteData);

                    // Start progress simulation to show user feedback
                    this.simulateProgressUpdates();

                    // Add terrain bounds if available from site boundary events
                    const enhancedSiteData = { ...this.siteData };
                    if (this.terrainBounds) {
                        enhancedSiteData.terrainBounds = this.terrainBounds;
                        console.log('[TerrainViewer] Using terrain bounds:', this.terrainBounds);
                    }

                    const response = await fetch('/api/generate-terrain', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            site_data: enhancedSiteData
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.terrainData = result;

                        // Store Mapbox tile info if provided
                        if (result.mapbox_tile_url) {
                            this.mapboxTileUrl = result.mapbox_tile_url;
                            console.log('[TerrainViewer] Received Mapbox tile URL:', this.mapboxTileUrl);
                        }

                        // Complete all steps as successful
                        for (let i = 1; i <= 7; i++) {
                            this.updateProgress(i, 'completed');
                        }
                        this.updateProgressBar(100);
                        this.updateProgressStatus('Complete!');

                        // Small delay to show completion before rendering
                        setTimeout(() => {
                            this.renderTerrain();
                            this.enableViewControls();
                            this.enableEarthworksControls();
                            this.enableBuildableAreaButton();
                            
                            // Refresh structure platform availability after terrain loads
                            setTimeout(() => {
                                this.checkStructurePlatformAvailability();
                            }, 500);
                            
                            this.showSuccess('3D Terrain Generated');
                            console.log('[TerrainViewer] Terrain generation completed successfully');

                            // Hide progress after a moment
                            setTimeout(() => {
                                this.showLoading(false);
                            }, 1500);
                        }, 500);
                    } else {
                        // Handle error - determine which step failed based on error message
                        let failedStep = 1;
                        const errorMsg = result.error || '';

                        if (errorMsg.includes('coordinates') || errorMsg.includes('geocoding')) {
                            failedStep = 1;
                        } else if (errorMsg.includes('city') || errorMsg.includes('region')) {
                            failedStep = 2;
                        } else if (errorMsg.includes('property') || errorMsg.includes('boundary')) {
                            failedStep = 3;
                        } else if (errorMsg.includes('DEM') || errorMsg.includes('tile')) {
                            failedStep = 4;
                        } else if (errorMsg.includes('download') || errorMsg.includes('elevation')) {
                            failedStep = 5;
                        } else if (errorMsg.includes('process') || errorMsg.includes('terrain')) {
                            failedStep = 6;
                        } else {
                            failedStep = 7;
                        }

                        // Mark previous steps as completed and current as error
                        for (let i = 1; i < failedStep; i++) {
                            this.updateProgress(i, 'completed');
                        }
                        this.updateProgress(failedStep, 'error');
                        this.updateProgressStatus(`Error: ${result.error}`);

                        this.showError(result.error || 'Failed to generate terrain data');                        console.error('[TerrainViewer] Terrain generation failed:', result.error);
                        this.showLoading(false);
                    }

                } catch (error) {
                    // Network or parsing error
                    this.updateProgress(1, 'error');
                    this.updateProgressStatus('Network error occurred');

                    this.showError(`Error: ${error.message}`);
                    console.error('[TerrainViewer] Terrain generation error:', error);
                    this.showLoading(false);
                }
            }

            simulateProgressUpdates() {
                // Simulate realistic progress through steps while backend processes
                const steps = [
                    { step: 1, delay: 200, message: 'Geocoding coordinates...' },
                    { step: 2, delay: 800, message: 'Identifying city region...' },
                    { step: 3, delay: 1500, message: 'Retrieving property boundary...' },
                    { step: 4, delay: 2500, message: 'Finding DEM tiles...' },
                    { step: 5, delay: 3500, message: 'Searching elevation data...' },
                    { step: 6, delay: 8000, message: 'Processing terrain data...' },
                    { step: 7, delay: 12000, message: 'Creating visualisation...' }
                ];

                steps.forEach(({ step, delay, message }) => {
                    setTimeout(() => {
                        // Only update if we're still loading (not completed or errored)
                        if (document.getElementById('progressContainer').style.display !== 'none') {
                            this.updateProgress(step, 'active');
                            this.updateProgressStatus(message);
                            this.updateProgressBar(this.progressSteps.find(s => s.id === step)?.weight || 0);
                        }
                    }, delay);
                });
            }

            renderTerrain() {
                if (!this.terrainData) return;

                const data = this.terrainData;
                const canvas = document.getElementById('terrainCanvas');

                // Create main terrain surface
                const traces = [];

                // Main terrain surface with contours
                traces.push({
                    type: 'surface',
                    z: data.elevation_data,
                    x: data.x_coords,
                    y: data.y_coords,
                    colorscale: [
                        [0, '#0d1421'],      // Deep navy (lowest elevation)
                        [0.15, '#1a2332'],   // Dark blue-grey
                        [0.3, '#2d4a5a'],    // Medium blue-grey
                        [0.45, '#547bf7'],   // EngineRoom blue
                        [0.6, '#6287ff'],    // Bright blue
                        [0.75, '#84a7f7'],   // Light blue
                        [0.85, '#a3c4f3'],   // Very light blue
                        [0.95, '#e8f2ff'],   // Almost white blue
                        [1, '#ffffff']       // Pure white (highest elevation)
                    ],
                    opacity: 1.0,
                    name: 'Terrain',
                    showscale: false,
                    contours: {
                        z: {
                            show: true,
                            usecolormap: false,
                            color: 'rgba(255, 255, 255, 0.4)',
                            width: 2,
                            project: { z: true },
                            highlightcolor: '#ff6b6b',
                            highlightwidth: 3
                        }
                    },
                    lighting: {
                        ambient: 0.9,
                        diffuse: 0.5,
                        specular: 0.02,
                        roughness: 0.8,
                        fresnel: 0.1
                    }
                });

                // Base level
                traces.push({
                    type: 'surface',
                    z: Array(data.elevation_data.length).fill(null).map(() => 
                        Array(data.elevation_data[0].length).fill(data.base_level)
                    ),
                    x: data.x_coords,
                    y: data.y_coords,
                    colorscale: [[0, 'rgba(13, 20, 33, 0.8)'], [1, 'rgba(13, 20, 33, 0.8)']],
                    showscale: false,
                    opacity: 0.7,
                    name: 'Base'
                });

                // Property boundary is hidden by default
                // (Property boundary trace removed to keep terrain view clean)
                // Add polygon overlays to the plot if available
                if (data.polygon_overlays) {
                    console.log('[TerrainViewer] Adding polygon overlays:', Object.keys(data.polygon_overlays));

                    Object.entries(data.polygon_overlays).forEach(([key, overlay]) => {
                        if (overlay.coordinates && overlay.coordinates.length > 0) {
                            console.log(`[TerrainViewer] Adding ${key} overlay with ${overlay.coordinates.length} coordinates`);

                            // Convert coordinates to x, y arrays for plotting
                            const overlayX = [];
                            const overlayY = [];

                            overlay.coordinates.forEach(coord => {
                                if (Array.isArray(coord) && coord.length >= 2) {
                                    // Convert from [lng, lat] to projected coordinates
                                    const projectedCoord = this.convertToProjectedCoords(coord[0], coord[1], data);
                                    overlayX.push(projectedCoord.x);
                                    overlayY.push(projectedCoord.y);
                                }
                            });

                            // Close the polygon by adding the first point at the end
                            if (overlayX.length > 0) {
                                overlayX.push(overlayX[0]);
                                overlayY.push(overlayY[0]);
                            }

                            // Determine line style and width based on overlay type
                            let lineWidth = 8;
                            let lineDash = 'solid';
                            let zOffset = 0.5;

                            if (key === 'site_boundary') {
                                lineWidth = 10;
                                zOffset = 0.8;
                            } else if (key === 'buildable_area') {
                                lineWidth = 6;
                                lineDash = 'dash';
                                zOffset = 0.6;
                            } else if (key === 'structure_placement') {
                                lineWidth = 8;
                                lineDash = 'dot';
                                zOffset = 1.0;
                            }

                            // Add to plot
                            traces.push({
                                type: 'scatter3d',
                                x: overlayX,
                                y: overlayY,
                                z: Array(overlayX.length).fill(data.base_level + zOffset),
                                mode: 'lines',
                                line: { 
                                    color: overlay.color || '#007cbf', 
                                    width: lineWidth,
                                    dash: lineDash
                                },
                                name: overlay.name || key,
                                showlegend: true,
                                opacity: 0.9
                            });

                            // Add area information to legend if available
                            if (overlay.area_m2) {
                                const lastTrace = traces[traces.length - 1];
                                lastTrace.name += ` (${overlay.area_m2.toFixed(1)} m²)`;
                            }
                        }
                    });

                    // Log overlay summary
                    const overlayTypes = Object.keys(data.polygon_overlays);
                    console.log(`[TerrainViewer] Successfully added ${overlayTypes.length} polygon overlays: ${overlayTypes.join(', ')}`);
                }

                // Calculate appropriate scaling for terrain visualisation
                const maxX = data.width_m || 50;
                const maxY = data.length_m || 50;
                const elevationRange = Math.max(...data.elevation_data.flat()) - Math.min(...data.elevation_data.flat());

                // Use a reasonable elevation scale - typically 2-3x the elevation range for good visibility
                const elevationScale = Math.max(elevationRange * 2.5, maxX * 0.3); // At least 30% of horizontal scale
                const maxDimension = Math.max(maxX, maxY);

                const layout = {
                    scene: {
                        aspectmode: 'cube',
                        xaxis: { 
                            title: 'Width (m)',
                            titlefont: { color: 'white', size: 14 },
                            tickformat: '.0f',
                            tickfont: { color: 'white', size: 12 },
                            showgrid: true,
                            gridcolor: 'rgba(255, 255, 255, 0.3)',
                            gridwidth: 2,
                            color: 'white',
                            showbackground: true,
                            backgroundcolor: 'rgba(13, 20, 33, 0.5)',
                            range: [0, maxX]
                        },
                        yaxis: { 
                            title: 'Length (m)',
                            titlefont: { color: 'white', size: 14 },
                            tickformat: '.0f',
                            tickfont: { color: 'white', size: 12 },
                            showgrid: true,
                            gridcolor: 'rgba(255, 255, 255, 0.3)',
                            gridwidth: 2,
                            color: 'white',
                            showbackground: true,
                            backgroundcolor: 'rgba(13, 20, 33, 0.5)',
                            range: [0, maxY]
                        },
                        zaxis: { 
                            title: 'Elevation (m)',
                            titlefont: { color: 'white', size: 14 },
                            tickformat: '.1f',
                            tickfont: { color: 'white', size: 12 },
                            showgrid: true,
                            gridcolor: 'rgba(255, 255, 255, 0.4)',
                            gridwidth: 2,
                            color: 'white',
                            showbackground: true,
                            backgroundcolor: 'rgba(13, 20, 33, 0.5)',
                            range: [Math.min(...data.elevation_data.flat()) - 1, Math.max(...data.elevation_data.flat()) + 2]
                        },
                        aspectmode: 'manual',
                        aspectratio: { 
                            x: 1, 
                            y: maxY/ maxX,                             z: elevationScale / maxDimension 
                                                },
                        bgcolor: '#0d1421',
                        camera: {
                            eye: { x: 0, y: -2.0, z: 1.2 },
                            center: { x: 0, y: 0, z: 0 },
                            up: { x: 0, y: 0, z: 1 }
                        }
                    },
                    margin: { l: 0, r: 60, b: 0, t: 50 },
                    paper_bgcolor: '#0d1421',
                    plot_bgcolor: '#0d1421',
                    font: { color: 'white', family: 'Inter, sans-serif' }
                };

                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d'],
                    displaylogo: false
                };

                Plotly.newPlot(canvas, traces, layout, config);
                this.plot = canvas;

                // Add mouse event listeners for platform dragging
                this.setupPlatformDragging();
            }

            setupPlatformDragging() {
                const canvas = document.getElementById('terrainCanvas');
                const plotlyDiv = canvas.querySelector('.plotly-graph-div') || canvas;

                const mouseDownHandler = (event) => {
                    if (!this.earthworksData || !this.platformMovementEnabled) return;

                    const coords = this.getTerrainCoordinates(event, plotlyDiv);

                    if (this.isNearPlatform(coords.x, coords.y)) {
                        this.startDrag(coords, plotlyDiv);
                    }
                };

                const mouseMoveHandler = (event) => {
                    if (!this.earthworksData || !this.platformMovementEnabled) return;

                    const coords = this.getTerrainCoordinates(event, plotlyDiv);

                    if (!this.isDragging) {
                        this.updateCursor(coords, plotlyDiv);
                        return;
                    }

                    this.updatePlatformPosition(coords);
                };

                const mouseUpHandler = () => {
                    if (this.isDragging) {
                        this.endDrag(plotlyDiv);
                    }
                };

                const mouseLeaveHandler = () => {
                    if (this.isDragging) {
                        this.endDrag(plotlyDiv);
                    }
                };

                // Clean up existing listeners
                this.removeDragListeners(plotlyDiv);

                // Add new listeners
                plotlyDiv.addEventListener('mousedown', mouseDownHandler);
                plotlyDiv.addEventListener('mousemove', mouseMoveHandler);
                plotlyDiv.addEventListener('mouseup', mouseUpHandler);
                plotlyDiv.addEventListener('mouseleave', mouseLeaveHandler);

                console.log('[TerrainViewer] Platform dragging setup complete');
            }

            getTerrainCoordinates(event, plotlyDiv) {
                const rect = plotlyDiv.getBoundingClientRect();
                const x = (event.clientX - rect.left) / rect.width;
                const y = 1 - ((event.clientY - rect.top) / rect.height); // Invert Y axis
                return { x, y };
            }

            startDrag(coords, plotlyDiv) {
                console.log('[TerrainViewer] Starting platform drag');

                this.isDragging = true;
                this.dragStartPosition = { ...this.currentPlatformCenter };
                this.dragOffset = { 
                    x: coords.x - this.currentPlatformCenter.x, 
                    y: coords.y - this.currentPlatformCenter.y 
                };

                plotlyDiv.style.cursor = 'grabbing';
                Plotly.relayout(document.getElementById('terrainCanvas'), {'dragmode': false});
                this.showDragFeedback(true);
            }

            updatePlatformPosition(coords) {
                // Calculate new position with offset
                let newX = coords.x - this.dragOffset.x;
                let newY = coords.y - this.dragOffset.y;

                // Keep platform within bounds
                const margin = 0.1;
                newX = Math.max(margin, Math.min(1 - margin, newX));
                newY = Math.max(margin, Math.min(1 - margin, newY));

                this.currentPlatformCenter = { x: newX, y: newY };
                this.updateDragFeedback();

                // Throttle recalculation
                this.throttleRecalculation();
            }

            endDrag(plotlyDiv) {
                console.log('[TerrainViewer] Ending platform drag');

                this.isDragging = false;
                plotlyDiv.style.cursor = 'default';

                Plotly.relayout(document.getElementById('terrainCanvas'), {'dragmode': 'orbit'});
                this.showDragFeedback(false);

                // Reset visual feedback to normal state
                this.updatePlatformVisualFeedback(false);

                this.clearThrottledRecalculation();

                // Only recalculate if position changed significantly
                if (this.hasPositionChanged()) {
                    this.recalculateEarthworks();
                }
            }

            updateCursor(coords, plotlyDiv) {
                if (!this.platformMovementEnabled) {
                    plotlyDiv.style.cursor = 'default';
                    this.updatePlatformVisualFeedback(false);
                    return;
                }

                const isNear = this.isNearPlatform(coords.x, coords.y);
                plotlyDiv.style.cursor = isNear ? 'grab' : 'default';

                // Update visual feedback for platform selection
                this.updatePlatformVisualFeedback(isNear);
            }

            updatePlatformVisualFeedback(isHovering) {
                if (!this.plot || !this.earthworksData) return;

                // Find the platform boundary trace
                const currentData = this.plot.data;
                const platformTraceIndex = currentData.findIndex(trace => 
                    trace.name && trace.name.includes('Building Platform')
                );

                if (platformTraceIndex === -1) return;

                // Create style updates for the platform trace
                const styleUpdate = {
                    'line.color': [isHovering ? '#a3c4f3' : '#84a7f7'], // Light blue when hovering, steel blue when normal
                    'line.width': [isHovering ? 16 : 12], // Thicker when hovering
                    'opacity': [isHovering ? 1.0 : 0.9]
                };

                // Update the trace styling
                Plotly.restyle(this.plot, styleUpdate, [platformTraceIndex]);
            }

            hasPositionChanged() {
                const threshold = 0.01;
                return Math.abs(this.currentPlatformCenter.x - this.dragStartPosition.x) > threshold ||
                       Math.abs(this.currentPlatformCenter.y - this.dragStartPosition.y) > threshold;
            }

            throttleRecalculation() {
                if (this.dragUpdateTimeout) {
                    clearTimeout(this.dragUpdateTimeout);
                }
                this.dragUpdateTimeout = setTimeout(() => {
                    this.updateEarthworksDisplay();
                    this.dragUpdateTimeout = null;
                }, 100);
            }

            clearThrottledRecalculation() {
                if (this.dragUpdateTimeout) {
                    clearTimeout(this.dragUpdateTimeout);
                    this.dragUpdateTimeout = null;
                }
            }

            convertToProjectedCoords(lng, lat, data) {
                /**
                 * Convert from geographic coordinates (lng, lat) to local projected coordinates
                 * based on the terrain data coordinate system
                 */
                try {
                    // Get the terrain bounds from the data
                    const terrainWidth = data.width_m || 50;
                    const terrainLength = data.length_m || 50;

                    // If we have x_coords and y_coords arrays, use them to determine the mapping
                    if (data.x_coords && data.y_coords && data.x_coords.length > 0 && data.y_coords.length > 0) {
                        // Get the min/max from the coordinate grids
                        const xCoords = data.x_coords.flat();
                        const yCoords = data.y_coords.flat();

                        const minX = Math.min(...xCoords);
                        const maxX = Math.max(...xCoords);
                        const minY = Math.min(...yCoords);
                        const maxY = Math.max(...yCoords);

                        // For now, use a simple linear mapping based on terrain bounds
                        // This is a simplified approach - in a real implementation you'd need proper coordinate transformation
                        const relativeX = (lng - data.coordinates.lng) * 111320 * Math.cos(data.coordinates.lat * Math.PI / 180);
                        const relativeY = (lat - data.coordinates.lat) * 111320;

                        // Map to terrain coordinate system
                        const terrainX = (terrainWidth / 2) + relativeX;
                        const terrainY = (terrainLength / 2) + relativeY;

                        return {
                            x: Math.max(0, Math.min(terrainWidth, terrainX)),
                            y: Math.max(0, Math.min(terrainLength, terrainY))
                        };
                    } else {
                        // Fallback to simple center-based mapping
                        return {
                            x: terrainWidth / 2,
                            y: terrainLength / 2
                        };
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error in convertToProjectedCoords:', error);
                    // Return center point as fallback
                    return {
                        x: (data.width_m || 50) / 2,
                        y: (data.length_m || 50) / 2
                    };
                }
            }

            removeDragListeners(plotlyDiv) {
                // Clean up any existing listeners to prevent duplicates
                const events = ['mousedown', 'mousemove', 'mouseup', 'mouseleave'];
                events.forEach(event => {
                    plotlyDiv.removeEventListener(event, this[`${event}Handler`]);
                });
            }

            isNearPlatform(x, y) {
                if (!this.earthworksData) return false;

                const dx = x - this.currentPlatformCenter.x;
                const dy = y - this.currentPlatformCenter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Threshold based on platform size relative to terrain
                const platformWidth = parseFloat(document.getElementById('platformWidth').value) || 10;
                const terrainWidth = this.terrainData?.width_m || 40;
                const relativeSize = platformWidth / terrainWidth;
                const threshold = Math.max(0.1, relativeSize * 1.5); // Adaptive threshold

                return distance <= threshold;
            }

            showDragFeedback(show) {
                const btn = document.getElementById('calculateEarthworksBtn');
                if (show) {
                    btn.textContent = 'Moving Platform...';
                    btn.disabled = true;
                    this.updatePlatformDragVisuals(true);
                } else {
                    btn.textContent = 'Calculate Earthworks';
                    btn.disabled = false;
                    this.updatePlatformDragVisuals(false);
                }
            }

            updatePlatformDragVisuals(isDragging) {
                if (!this.plot || !this.earthworksData) return;

                const currentData = this.plot.data;
                const platformTraceIndex = currentData.findIndex(trace => 
                    trace.name && trace.name.includes('Building Platform')
                );

                if (platformTraceIndex === -1) return;

                // Create style updates for dragging state
                const styleUpdate = {
                    'line.color': [isDragging ? '#cd853f' : '#84a7f7'], // Warm brown when dragging, steel blue when normal
                    'line.width': [isDragging ? 18 : 12], // Extra thick when dragging
                    'line.dash': [isDragging ? 'dash' : 'solid'], // Dashed line when dragging
                    'opacity': [isDragging ? 1.0 : 0.9]
                };

                Plotly.restyle(this.plot, styleUpdate, [platformTraceIndex]);
            }

            updateDragFeedback() {
                if (!this.isDragging || !this.terrainData) return;

                const x = Math.round(this.currentPlatformCenter.x * this.terrainData.width_m);
                const y = Math.round(this.currentPlatformCenter.y * this.terrainData.length_m);

                document.getElementById('calculateEarthworksBtn').textContent = `Position: ${x}m, ${y}m`;
            }

            async updateEarthworksDisplay() {
                // Lightweight update during drag - only update display values
                if (!this.terrainData || !this.isDragging) return;

                try {
                    const platformCoords = this.getCurrentPlatformCoords();
                    const optimizeFfl = document.querySelector('input[name="fflMode"][value="optimize"]').checked;
                    const manualFfl = optimizeFfl ? null : parseFloat(document.getElementById('manualFFL').value);

                    const response = await fetch('/api/calculate-earthworks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            terrain_data: this.terrainData,
                            platform_coords: platformCoords,
                            ffl: manualFfl,
                            optimize_ffl: optimizeFfl
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.earthworksData = result;
                        this.displayEarthworksResults(result);
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Update earthworks display error:', error);
                }
            }

            async recalculateEarthworks() {
                // Full recalculation with visualisation update
                if (!this.terrainData) return;

                try {
                    this.clearMessages();
                    this.setButtonState('calculating');

                    const platformCoords = this.getCurrentPlatformCoords();
                    const optimizeFfl = document.querySelector('input[name="fflMode"][value="optimize"]').checked;
                    const manualFfl = optimizeFfl ? null : parseFloat(document.getElementById('manualFFL').value);

                    const response = await fetch('/api/calculate-earthworks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            terrain_data: this.terrainData,
                            platform_coords: platformCoords,
                            ffl: manualFfl,
                            optimize_ffl: optimizeFfl
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.earthworksData = result;
                        this.displayEarthworksResults(result);
                        this.renderTerrainWithPlatform();
                        this.showSuccess('Earthworks updated successfully');
                        document.getElementById('clearPlatformBtn').disabled = false;
                    } else {
                        this.showError(result.error || 'Failed to calculate earthworks');
                    }
                } catch (error) {
                    this.showError(`Error: ${error.message}`);
                    console.error('[TerrainViewer] Earthworks calculation error:', error);
                } finally {
                    this.setButtonState('ready');
                }
            }

            getCurrentPlatformCoords() {
                const width = parseFloat(document.getElementById('platformWidth').value) || 15;
                const length = parseFloat(document.getElementById('platformLength').value) || 20;

                return this.calculateRotatedPlatformCoords(
                    this.currentPlatformCenter, 
                    width, 
                    length, 
                    this.terrainData.width_m, 
                    this.terrainData.length_m, 
                    this.currentPlatformRotation
                );
            }

            setButtonState(state) {
                const btn = document.getElementById('calculateEarthworksBtn');
                switch (state) {
                    case 'calculating':
                        btn.textContent = 'Updating...';
                        btn.disabled = true;
                        break;
                    case 'ready':
                    default:
                        btn.textContent = 'Calculate Earthworks';
                        btn.disabled = false;
                        break;
                }
            }

            enableViewControls() {
                this.safeSetProperty('resetViewBtn', 'disabled', false);
                this.safeSetProperty('topViewBtn', 'disabled', false);
                this.safeSetProperty('sideViewBtn', 'disabled', false);
                this.safeSetProperty('perspectiveViewBtn', 'disabled', false);
            }

            enableEarthworksControls() {
                this.safeSetProperty('calculateEarthworksBtn', 'disabled', false);
            }

            safeSetProperty(elementId, property, value) {
                try {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element[property] = value;
                    } else {
                        console.warn(`[TerrainViewer] Element ${elementId} not found, cannot set ${property}`);
                    }
                } catch (error) {
                    console.error(`[TerrainViewer] Error setting ${property} on ${elementId}:`, error);
                }
            }

            safeGetElement(elementId) {
                try {
                    return document.getElementById(elementId);
                } catch (error) {
                    console.error(`[TerrainViewer] Error getting element ${elementId}:`, error);
                    return null;
                }
            }

            enableBuildableAreaButton() {
                console.log('[TerrainViewer] Enabling buildable area button');
                const btn = this.safeGetElement('loadBuildableAreaBtn');
                if (!btn) {
                    console.error('[TerrainViewer] Load buildable area button not found');
                    return;
                }

                // Check if site data has buildable area
                if (this.siteData && this.siteData.buildable_area && 
                    this.siteData.buildable_area.coordinates && 
                    this.siteData.buildable_area.coordinates.length > 0) {

                    const area = this.siteData.buildable_area.area_m2 || this.calculatePolygonArea(this.siteData.buildable_area.coordinates);
                    this.safeSetProperty('loadBuildableAreaBtn', 'disabled', false);
                    btn.textContent = `Load Buildable Area (${area.toFixed(1)} m²)`;
                    console.log('[TerrainViewer] Buildable area available:', area.toFixed(1), 'm²');
                } else {
                    this.safeSetProperty('loadBuildableAreaBtn', 'disabled', true);
                    btn.textContent = 'No Buildable Area Available';
                    console.log('[TerrainViewer] Buildable area button disabled - no buildable area data');
                }

                // Also check structure platform availability
                this.checkStructurePlatformAvailability();
            }

            checkBuildableAreaAvailability() {
                console.log('[TerrainViewer] Checking buildable area availability');

                // Check if site data has buildable area
                if (this.siteData && this.siteData.buildable_area && 
                    this.siteData.buildable_area.coordinates && 
                    this.siteData.buildable_area.coordinates.length > 0) {

                    const btn = document.getElementById('loadBuildableAreaBtn');
                    btn.disabled = false;
                    btn.textContent = `Load Buildable Area (${this.siteData.buildable_area.area_m2.toFixed(1)} m²)`;
                    console.log('[TerrainViewer] Buildable area available:', this.siteData.buildable_area.area_m2.toFixed(1), 'm²');
                } else {
                    console.log('[TerrainViewer] Buildable area button disabled - no buildable area data');
                }

                // Check for structure placement data
                this.checkStructurePlatformAvailability();
            }

            checkStructurePlatformAvailability() {
                console.log('[TerrainViewer] Checking structure platform availability');

                // Check multiple sources for structure placement data
                let structureData = null;
                
                // Check session storage for structure placement data
                try {
                    const sessionData = sessionStorage.getItem('structure_placement_data');
                    if (sessionData && sessionData !== 'undefined') {
                        structureData = JSON.parse(sessionData);
                        console.log('[TerrainViewer] Found structure data in session storage');
                    }
                } catch (error) {
                    console.log('[TerrainViewer] Error parsing session data:', error);
                }

                // Check site data for structure placement
                if (!structureData && this.siteData && this.siteData.structure_placement) {
                    structureData = this.siteData.structure_placement;
                    console.log('[TerrainViewer] Found structure data in site data');
                }

                // Check terrain data for structure overlays
                if (!structureData && this.terrainData && this.terrainData.polygon_overlays && this.terrainData.polygon_overlays.structure_placement) {
                    structureData = this.terrainData.polygon_overlays.structure_placement;
                    console.log('[TerrainViewer] Found structure data in terrain overlays');
                }

                const btn = document.getElementById('loadPlatformBtn');
                if (btn) {
                    if (structureData && structureData.coordinates && structureData.coordinates.length > 0) {
                        btn.disabled = false;
                        const area = structureData.area_m2 || this.calculatePolygonArea(structureData.coordinates);
                        btn.textContent = `Load Structure Platform (${area.toFixed(1)} m²)`;
                        console.log('[TerrainViewer] Structure platform available:', area.toFixed(1), 'm²');
                    } else {
                        btn.disabled = true;
                        btn.textContent = 'No Structure Available';
                        console.log('[TerrainViewer] No structure platform data available');
                    }
                }
            }

            async loadStructurePlatform() {
                console.log('[TerrainViewer] Loading structure platform...');

                if (!this.terrainData) {
                    this.showError('Please generate terrain data first');
                    return;
                }

                const btn = document.getElementById('loadPlatformBtn');
                const originalText = btn.textContent;
                btn.disabled = true;
                btn.textContent = 'Loading...';

                try {
                    // Get structure placement data
                    let structureData = null;
                    try {
                        const sessionData = sessionStorage.getItem('structure_placement_data');
                        if (sessionData) {
                            structureData = JSON.JSON.parse(sessionData);
                        }
                    } catch (error) {
                        console.log('[TerrainViewer] No structure data in session');
                    }

                    // Fallback to site data
                    if (!structureData && this.siteData && this.siteData.structure_placement) {
                        structureData = this.siteData.structure_placement;
                    }

                    if (!structureData || !structureData.coordinates || structureData.coordinates.length < 3) {
                        throw new Error('No valid structure placement data found');
                    }

                    console.log('[TerrainViewer] Structure data loaded:', structureData);

                    // Convert coordinates to platform format
                    const platformCoords = structureData.coordinates.map(coord => {
                        if (Array.isArray(coord)) {
                            return { x: coord[0], y: coord[1] };
                        }
                        return coord;
                    });

                    // Calculate platform center and dimensions
                    const bounds = this.calculatePolygonBounds(platformCoords);
                    const center = {
                        x: (bounds.minX + bounds.maxX) / 2,
                        y: (bounds.minY + bounds.maxY) / 2
                    };
                    const width = Math.abs(bounds.maxX - bounds.minX);
                    const length = Math.abs(bounds.maxY - bounds.minY);

                    // Store platform data
                    this.structurePlatformData = {
                        coordinates: platformCoords,
                        center: center,
                        width: width,
                        length: length,
                        area: structureData.area_m2 || this.calculatePolygonArea(platformCoords),
                        originalData: structureData
                    };

                    // Update UI controls
                    document.getElementById('platformWidth').value = width.toFixed(1);
                    document.getElementById('platformLength').value = length.toFixed(1);
                    document.getElementById('platformCenterX').value = center.x.toFixed(6);
                    document.getElementById('platformCenterY').value = center.y.toFixed(6);
                    document.getElementById('platformRotation').value = 0;
                    document.getElementById('platformRotationValue').value = 0;

                    // Show platform controls
                    document.getElementById('platformControls').style.display = 'block';

                    // Initialize platform visualization
                    this.currentPlatformCoords = platformCoords;
                    this.currentPlatformCenter = center;
                    this.currentPlatformRotation = 0;

                    this.showSuccess(`Structure platform loaded (${this.structurePlatformData.area.toFixed(1)} m²)`);

                } catch (error) {
                    this.showError(`Error loading structure platform: ${error.message}`);
                    console.error('[TerrainViewer] Structure platform loading error:', error);
                } finally {
                    btn.disabled = false;
                    btn.textContent = originalText;
                }
            }

            calculatePolygonBounds(coords) {
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                coords.forEach(coord => {
                    const x = coord.x || coord[0];
                    const y = coord.y || coord[1];
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                });

                return { minX, maxX, minY, maxY };
            }

            calculatePolygonArea(coords) {
                if (coords.length < 3) return 0;

                let area = 0;
                for (let i = 0; i < coords.length; i++) {
                    const j = (i + 1) % coords.length;
                    const xi = coords[i].x || coords[i][0];
                    const yi = coords[i].y || coords[i][1];
                    const xj = coords[j].x || coords[j][0];
                    const yj = coords[j].y || coords[j][1];
                    area += xi * yj;
                    area -= xj * yi;
                }
                return Math.abs(area / 2);
            }

            updatePlatformPosition() {
                if (!this.structurePlatformData) return;

                const centerX = parseFloat(document.getElementById('platformCenterX').value);
                const centerY = parseFloat(document.getElementById('platformCenterY').value);

                this.currentPlatformCenter = { x: centerX, y: centerY };
                this.updatePlatformVisualization();
            }

            updatePlatformVisualization() {
                if (!this.structurePlatformData) return;

                const width = parseFloat(document.getElementById('platformWidth').value);
                const length = parseFloat(document.getElementById('platformLength').value);
                const rotation = parseFloat(document.getElementById('platformRotation').value);

                // Calculate new coordinates based on center, dimensions, and rotation
                this.currentPlatformCoords = this.calculateRotatedPlatformCoords(
                    this.currentPlatformCenter,
                    width,
                    length,
                    this.terrainData.width_m,
                    this.terrainData.length_m,
                    rotation
                );

                // Update visualization if terrain is displayed
                if (this.plot) {
                    this.updatePlatformTrace();
                }
            }

            updatePlatformTrace() {
                if (!this.plot || !this.currentPlatformCoords) return;

                // Find existing platform trace
                const data = this.plot.data;
                let platformTraceIndex = -1;

                for (let i = 0; i < data.length; i++) {
                    if (data[i].name && data[i].name.includes('Building Platform')) {
                        platformTraceIndex = i;
                        break;
                    }
                }

                // Create platform coordinates for 3D visualization
                const platformX = this.currentPlatformCoords.map(coord => coord.x * this.terrainData.width_m);
                const platformY = this.currentPlatformCoords.map(coord => coord.y * this.terrainData.length_m);
                const platformZ = platformX.map(() => 0); // Will be updated with FFL when calculated

                const platformTrace = {
                    x: [...platformX, platformX[0]], // Close the polygon
                    y: [...platformY, platformY[0]],
                    z: [...platformZ, platformZ[0]],
                    mode: 'lines',
                    type: 'scatter3d',
                    line: {
                        color: '#ff6b35',
                        width: 8
                    },
                    name: 'Building Platform',
                    showlegend: true
                };

                if (platformTraceIndex >= 0) {
                    // Update existing trace
                    Plotly.restyle(this.plot, platformTrace, [platformTraceIndex]);
                } else {
                    // Add new trace
                    Plotly.addTraces(this.plot, [platformTrace]);
                }
            }

            resetPlatform() {
                if (!this.structurePlatformData) return;

                // Reset to original values
                const original = this.structurePlatformData;
                document.getElementById('platformWidth').value = original.width.toFixed(1);
                document.getElementById('platformLength').value = original.length.toFixed(1);
                document.getElementById('platformCenterX').value = original.center.x.toFixed(6);
                document.getElementById('platformCenterY').value = original.center.y.toFixed(6);
                document.getElementById('platformRotation').value = 0;
                document.getElementById('platformRotationValue').value = 0;

                this.currentPlatformCenter = { ...original.center };
                this.currentPlatformRotation = 0;
                this.updatePlatformVisualization();

                this.showSuccess('Platform reset to original values');
            }

            async calculatePlatformEarthworks() {
                if (!this.structurePlatformData || !this.terrainData) {
                    this.showError('Platform and terrain data required');
                    return;
                }

                const btn = document.getElementById('confirmPlatformBtn');
                const originalText = btn.textContent;
                btn.disabled = true;
                btn.textContent = 'Calculating...';

                try {
                    // Get current platform coordinates
                    const platformCoords = this.currentPlatformCoords.map(coord => ({
                        x: coord.x,
                        y: coord.y
                    }));

                    // Get FFL parameters
                    const optimizeFfl = document.querySelector('input[name="fflMode"][value="optimize"]').checked;
                    const manualFfl = optimizeFfl ? null : parseFloat(document.getElementById('manualFFL').value);

                    console.log('[TerrainViewer] Calculating earthworks for platform...', {
                        platformCoords,
                        optimizeFfl,
                        manualFfl
                    });

                    const response = await fetch('/api/calculate-earthworks', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            terrain_data: this.terrainData,
                            platform_coords: platformCoords,
                            ffl: manualFfl,
                            optimize_ffl: optimizeFfl
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.earthworksData = result;
                        this.displayEarthworksResults(result);
                        this.renderTerrainWithPlatform();
                        this.showSuccess(`Platform earthworks calculated successfully (${result.platform_area_m2.toFixed(1)} m²)`);

                        // Enable other controls
                        document.getElementById('clearPlatformBtn').disabled = false;
                        document.getElementById('togglePlatformMoveBtn').disabled = false;
                    } else {
                        this.showError(result.error || 'Failed to calculate platform earthworks');
                    }

                } catch (error) {
                    this.showError(`Error: ${error.message}`);
                    console.error('[TerrainViewer] Platform earthworks calculation error:', error);
                } finally {
                    btn.disabled = false;
                    btn.textContent = originalText;
                }
            }

            clearPlatform() {
                this.clearMessages();

                // Clear earthworks data
                this.earthworksData = null;

                // Clear structure platform data
                this.structurePlatformData = null;
                this.currentPlatformCoords = null;

                // Clear results display
                const resultsElement = this.safeGetElement('earthworksResults');
                if (resultsElement) resultsElement.style.display = 'none';

                // Hide platform controls
                const controlsElement = this.safeGetElement('platformControls');
                if (controlsElement) controlsElement.style.display = 'none';

                // Clear platform position
                this.currentPlatformCenter = { x: 0.5, y: 0.5 };
                this.currentPlatformRotation = 0;

                // Reset platform controls using safe methods
                const resetValues = [
                    ['platformRotation', 0],
                    ['platformRotationValue', 0],
                    ['platformWidth', 10],
                    ['platformLength', 10],
                    ['platformCenterX', 0],
                    ['platformCenterY', 0]
                ];

                resetValues.forEach(([id, value]) => {
                    const element = this.safeGetElement(id);
                    if (element) element.value = value;
                });

                // Disable platform controls
                this.safeSetProperty('clearPlatformBtn', 'disabled', true);
                this.safeSetProperty('togglePlatformMoveBtn', 'disabled', true);

                // Re-check platform availability
                this.checkStructurePlatformAvailability();

                // Re-render terrain without platform
                if (this.terrainData) {
                    this.renderTerrain(this.terrainData);
                }

                this.showSuccess('Platform cleared');
            }

            // View control methods
            resetView() {
                if (this.plot) {
                    Plotly.relayout(this.plot, {
                        'scene.camera': {
                            eye: { x: 0, y: -2.0, z: 1.2 },
                            center: { x: 0, y: 0, z: 0 },
                            up: { x: 0, y: 0, z: 1 }
                        }
                    });
                }
            }

            setTopView() {
                if (this.plot) {
                    Plotly.relayout(this.plot, {
                        'scene.camera': {
                            eye: { x: 0, y: 0, z: 2.5 },
                            center: { x: 0, y: 0, z: 0 },
                            up: { x: 0, y: 1, z: 0 }
                        }
                    });
                }
            }

            setSideView() {
                if (this.plot) {
                    Plotly.relayout(this.plot, {
                        'scene.camera': {
                            eye: { x: 0, y: -2.5, z: 0 },
                            center: { x: 0, y: 0, z: 0 },
                            up: { x: 0, y: 0, z: 1 }
                        }
                    });
                }
            }

            setPerspectiveView() {
                if (this.plot) {
                    Plotly.relayout(this.plot, {
                        'scene.camera': {
                            eye: { x: 1.5, y: -1.5, z: 1.2 },
                            center: { x: 0, y: 0, z: 0 },
                            up: { x: 0, y: 0, z: 1 }
                        }
                    });
                }
            }

            loadBuildableAreaAsPlatform() {
                console.log('[TerrainViewer] Loading buildable area as platform');
                if (!this.siteData || !this.siteData.buildable_area) {
                    this.showError('No buildable area data available');
                    return;
                }
                // Implementation would go here
            }

            calculateEarthworks() {
                console.log('[TerrainViewer] Calculate earthworks');
                if (!this.terrainData) {
                    this.showError('Please generate terrain data first');
                    return;
                }
                // Implementation would go here
            }

            updateFflMode() {
                console.log('[TerrainViewer] Update FFL mode');
                // Implementation would go here
            }

            updateRotation(value) {
                console.log('[TerrainViewer] Update rotation:', value);
                const rotationValue = document.getElementById('platformRotationValue');
                const rotationSlider = document.getElementById('platformRotation');
                
                if (rotationValue && rotationSlider) {
                    rotationValue.value = value;
                    rotationSlider.value = value;
                    this.currentPlatformRotation = parseFloat(value);
                }
            }

            togglePlatformMovement() {
                this.platformMovementEnabled = !this.platformMovementEnabled;
                console.log('[TerrainViewer] Platform movement:', this.platformMovementEnabled ? 'enabled' : 'disabled');
            }

            updatePlatformDimensions() {
                if (!this.structurePlatformData) return;
                
                const width = parseFloat(document.getElementById('platformWidth').value) || 10;
                const length = parseFloat(document.getElementById('platformLength').value) || 10;
                
                console.log('[TerrainViewer] Platform dimensions updated:', { width, length });
            }

            toggleLayer(layerType, visible) {
                if (!this.plot) {
                    console.warn(`[TerrainViewer] No plot available for ${layerType} layer toggle`);
                    return;
                }

                try {
                    const currentData = this.plot.data;
                    let traceIndices = [];

                    // Find relevant traces based on layer type with more comprehensive matching
                    switch (layerType) {
                        case 'terrain':
                            traceIndices = currentData.map((trace, index) => {
                                if (!trace.name) return -1;
                                const name = trace.name.toLowerCase();
                                return (name.includes('terrain') && !name.includes('base')) ? index : -1;
                            }).filter(index => index !== -1);
                            break;
                        case 'boundary':
                            traceIndices = currentData.map((trace, index) => {
                                if (!trace.name) return -1;
                                const name = trace.name.toLowerCase();
                                return (name.includes('property boundary') || name.includes('site boundary')) ? index : -1;
                            }).filter(index => index !== -1);
                            break;
                        case 'buildable':
                            traceIndices = currentData.map((trace, index) => {
                                if (!trace.name) return -1;
                                const name = trace.name.toLowerCase();
                                return (name.includes('buildable') || name.includes('buildable area') || name.includes('buildable_area')) ? index : -1;
                            }).filter(index => index !== -1);
                            break;
                        case 'structure':
                            traceIndices = currentData.map((trace, index) => {
                                if (!trace.name) return -1;
                                const name = trace.name.toLowerCase();
                                return (name.includes('structure') || name.includes('structure_placement')) ? index : -1;
                            }).filter(index => index !== -1);
                            break;
                        case 'platform':
                            traceIndices = currentData.map((trace, index) => {
                                if (!trace.name) return -1;
                                const name = trace.name.toLowerCase();
                                return (name.includes('platform') || name.includes('building platform')) ? index : -1;
                            }).filter(index => index !== -1);
                            break;
                    }

                    // Update visibility for found traces
                    if (traceIndices.length > 0) {
                        // Use proper Plotly visibility values - true for visible, false for hidden
                        const update = { visible: visible };
                        Plotly.restyle(this.plot, update, traceIndices);
                        console.log(`[TerrainViewer] Toggled ${layerType} layer: ${visible ? 'visible' : 'hidden'} (${traceIndices.length} traces affected)`);

                        // Force plot refresh
                        Plotly.redraw(this.plot);
                    } else {
                        console.warn(`[TerrainViewer] No traces found for ${layerType} layer - available traces:`, currentData.map(t => t.name));

                        // Debug: log all trace names to help identify the issue
                        console.log(`[TerrainViewer] All available traces for ${layerType}:`, 
                            currentData.map((trace, index) => `${index}: ${trace.name || 'unnamed'}`));
                    }

                } catch (error) {
                    console.error(`[TerrainViewer] Error toggling ${layerType} layer:`, error);
                }
            }

            toggleContours(visible) {
                if (!this.plot) {
                    console.warn('[TerrainViewer] No plot available for contour toggle');
                    return;
                }

                try {
                    const currentData = this.plot.data;
                    const terrainTraceIndices = currentData.map((trace, index) => {
                        if (!trace.name || trace.type !== 'surface') return -1;
                        const name = trace.name.toLowerCase();
                        return (name.includes('terrain') && !name.includes('base')) ? index : -1;
                    }).filter(index => index !== -1);

                    if (terrainTraceIndices.length > 0) {
                        const update = {
                            'contours.z.show': visible
                        };
                        Plotly.restyle(this.plot, update, terrainTraceIndices);
                        console.log(`[TerrainViewer] Contours ${visible ? 'enabled' : 'disabled'} for ${terrainTraceIndices.length} terrain surfaces`);

                        // Force plot refresh  
                        Plotly.redraw(this.plot);
                    } else {
                        console.warn(`[TerrainViewer] No terrain surface traces found for contour toggle`);
                        console.log(`[TerrainViewer] Available surface traces:`, 
                            currentData.filter(t => t.type === 'surface').map(t => t.name));
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error toggling contours:', error);
                }
            }

            updateTerrainOpacity(opacity) {
                if (!this.plot) {
                    console.warn('[TerrainViewer] No plot available for opacity update');
                    return;
                }

                try {
                    const opacityValue = parseFloat(opacity);
                    document.getElementById('terrainOpacityValue').textContent = opacityValue.toFixed(1);

                    const currentData = this.plot.data;
                    const terrainTraceIndices = currentData.map((trace, index) => {
                        if (!trace.name || trace.type !== 'surface') return -1;
                        const name = trace.name.toLowerCase();
                        return name.includes('terrain') && !name.includes('base') ? index : -1;
                    }).filter(index => index !== -1);

                    if (terrainTraceIndices.length > 0) {
                        const update = { opacity: opacityValue };
                        Plotly.restyle(this.plot, update, terrainTraceIndices);
                        console.log(`[TerrainViewer] Updated terrain opacity to ${opacityValue} for ${terrainTraceIndices.length} terrain surfaces`);

                        // Force plot refresh
                        Plotly.redraw(this.plot);
                    } else {
                        console.warn(`[TerrainViewer] No terrain surface traces found for opacity update - available surfaces:`, 
                            currentData.filter(t => t.type === 'surface').map(t => t.name));
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error updating terrain opacity:', error);
                }
            }

            updateVerticalScale(scale) {
                if (!this.plot || !this.terrainData) return;

                try {
                    const scaleValue = parseFloat(scale);
                    document.getElementById('verticalScaleValue').textContent = scaleValue.toFixed(1) + 'x';

                    const data = this.terrainData;
                    const maxX = data.width_m || 50;
                    const maxY = data.length_m || 50;
                    const elevationRange = Math.max(...data.elevation_data.flat()) - Math.min(...data.elevation_data.flat());
                    const elevationScale = Math.max(elevationRange * scaleValue, maxX * 0.3);
                    const maxDimension = Math.max(maxX, maxY);

                    const update = {
                        'scene.aspectratio.z': elevationScale / maxDimension
                    };

                    Plotly.relayout(this.plot, update);
                    console.log(`[TerrainViewer] Updated vertical scale to ${scaleValue}x`);
                } catch (error) {
                    console.error('[TerrainViewer] Error updating vertical scale:', error);
                }
            }

            updateColorScheme(scheme) {
                if (!this.plot) return;

                try {
                    const colorScales = {
                        terrain: [
                            [0, '#0d1421'],      // Deep navy
                            [0.15, '#1a2332'],   // Dark blue-grey
                            [0.3, '#2d4a5a'],    // Medium blue-grey
                            [0.45, '#547bf7'],   // EngineRoom blue
                            [0.6, '#6287ff'],    // Bright blue
                            [0.75, '#84a7f7'],   // Light blue
                            [0.85, '#a3c4f3'],   // Very light blue
                            [0.95, '#e8f2ff'],   // Almost white blue
                            [1, '#ffffff']       // Pure white
                        ],
                        elevation: [
                            [0, '#1a472a'],     // Dark green
                            [0.2, '#2d7c47'],   // Forest green
                            [0.4, '#48cc6c'],   // Green
                            [0.6, '#ffd23f'],   // Yellow
                            [0.8, '#ff8c42'],   // Orange
                            [1, '#8b4513']      // Brown
                        ],
                        viridis: 'Viridis',
                        plasma: 'Plasma',
                        grayscale: [[0, '#000000'], [1, '#ffffff']]
                    };

                    const currentData = this.plot.data;
                    const terrainTraceIndices = currentData.map((trace, index) => {
                        if (!trace.name || trace.type !== 'surface') return -1;
                        const name = trace.name.toLowerCase();
                        return name.includes('terrain') && !name.includes('base') ? index : -1;
                    }).filter(index => index !== -1);

                    if (terrainTraceIndices.length > 0) {
                        const update = { colorscale: colorScales[scheme] };
                        Plotly.restyle(this.plot, update, terrainTraceIndices);
                        console.log(`[TerrainViewer] Updated color scheme to ${scheme} for ${terrainTraceIndices.length} terrain surfaces`);

                        // Force plot refresh
                        Plotly.redraw(this.plot);
                    } else {
                        console.warn(`[TerrainViewer] No terrain surface traces found for color scheme update`);
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error updating color scheme:', error);
                }
            }

            toggleGrid(visible) {
                if (!this.plot) {
                    console.warn('[TerrainViewer] No plot available for grid toggle');
                    return;
                }

                try {
                    const update = {
                        'scene.xaxis.showgrid': visible,
                        'scene.yaxis.showgrid': visible,
                        'scene.zaxis.showgrid': visible
                    };

                    Plotly.relayout(this.plot, update);
                    console.log(`[TerrainViewer] Grid ${visible ? 'enabled' : 'disabled'}`);
                } catch (error) {
                    console.error('[TerrainViewer] Error toggling grid:', error);
                }
            }

            toggleAutoRotate(enabled) {
                if (!this.plot) return;

                try {
                    if (enabled) {
                        this.autoRotateInterval = setInterval(() => {
                            if (this.plot && this.plot.layout && this.plot.layout.scene && this.plot.layout.scene.camera) {
                                const camera = this.plot.layout.scene.camera;
                                const eye = camera.eye;

                                // Calculate new position for slow rotation
                                const angle = Date.now() * 0.0005; // Slow rotation
                                const radius = Math.sqrt(eye.x * eye.x + eye.y * eye.y);

                                const newEye = {
                                    x: radius * Math.cos(angle),
                                    y: radius * Math.sin(angle),
                                    z: eye.z
                                };

                                Plotly.relayout(this.plot, {
                                    'scene.camera.eye': newEye
                                });
                            }
                        }, 100);
                        console.log('[TerrainViewer] Auto-rotate enabled');
                    } else {
                        if (this.autoRotateInterval) {
                            clearInterval(this.autoRotateInterval);
                            this.autoRotateInterval = null;
                        }
                        console.log('[TerrainViewer] Auto-rotate disabled');
                    }
                } catch (error) {
                    console.error('[TerrainViewer] Error toggling auto-rotate:', error);
                }
            }

            info(message, data = {}) {
                console.info(`[TerrainViewer] ${message}`, data);
            }

            warn(message, data = {}) {
                console.warn(`[TerrainViewer] ${message}`, data);
            }
        }

        // Function to navigate to engineering flow step
        function navigateToStep(stepNumber, projectId) {
            // Get project ID from multiple sources
            if (!projectId) {
                // Try to get from template variable
                projectId = {{ project.id if project else 'null' }};

                // If still not found, try URL parameters
                if (!projectId || projectId === null) {
                    const urlParams = new URLSearchParams(window.location.search);
                    projectId = urlParams.get('project_id') || urlParams.get('project');
                }
            }

            // Clean up malformed project IDs (remove any extra parameters)
            if (projectId && typeof projectId === 'string' && projectId.includes('?')) {
                projectId = projectId.split('?')[0];
                console.log('[TerrainViewer] Cleaned malformed project ID for navigation:', projectId);
            }

            // Validate project ID
            if (projectId) {
                projectId = String(projectId).trim();
                if (!/^\d+$/.test(projectId)) {
                    console.error('[TerrainViewer] Invalid project ID format:', projectId);
                    return;
                }
            }

            console.log('[TerrainViewer] Navigating to step', stepNumber, 'with project ID:', projectId);

            const routes = {
                1: `/site-inspector?project_id=${projectId}`,
                2: `/terrain-viewer?project_id=${projectId}`,
                3: `/site-developer?project_id=${projectId}`,
                4: `/structure-designer?project_id=${projectId}`,
                5: `/structural-analyser?project_id=${projectId}`
            };

            if (routes[stepNumber] && projectId) {
                window.location.href = routes[stepNumber];
            } else {
                console.error('[TerrainViewer] No valid project ID available for navigation. ProjectId:', projectId);
            }
        }

        // Initialize terrain viewer
        document.addEventListener('DOMContentLoaded', () => {
            // Wait a bit for all DOM elements to be fully rendered
            setTimeout(() => {
                try {
                    const terrainViewer = new TerrainViewer();
                    console.log('[TerrainViewer] Successfully initialized');
                } catch (error) {
                    console.error('[TerrainViewer] Failed to initialize:', error);
                }

                // Set authenticated class on body for ADAM widget
                document.body.classList.add('authenticated');

                // Initialize ADAM chat widget if not already initialized
                if (typeof ADAMChatWidget !== 'undefined' && !window.adamChat) {
                    try {
                        window.adamChat = new ADAMChatWidget();
                        console.log('ADAM chat widget initialized successfully on terrain viewer page');
                    } catch (error) {
                        console.error('Failed to initialize ADAM chat widget on terrain viewer page:', error);
                    }
                }
            }, 100);
        });
    </script>

    <!-- ADAM Chat Widget -->
    <script src="{{ url_for('static', filename='js/adam-chat-widget.js') }}"></script>
</body>
</html>