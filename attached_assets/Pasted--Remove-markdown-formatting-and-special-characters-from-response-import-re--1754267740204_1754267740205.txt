       """Remove markdown formatting and special characters from response"""
        import re

        # Don't clean responses that contain script tags - they're needed for platform functionality
        if '<script>' in response:
            return response

        # Remove markdown headers
        response = re.sub(r'^#+\s*', '', response, flags=re.MULTILINE)

        # Remove bold/italic markdown
        response = re.sub(r'\*\*(.*?)\*\*', r'\1', response)
        response = re.sub(r'\*(.*?)\*', r'\1', response)

        # Remove special emoji/unicode characters
        response = re.sub(r'[‚úÖ‚ùåüéâüîßüìä‚ö°üöÄüí°]', '', response)

        # Remove code blocks but preserve script tags
        response = re.sub(r'```(?!.*<script)[\s\S]*?```', '', response)
        response = re.sub(r'`((?!<script).*?)`', r'\1', response)

        # Clean up extra whitespace and newlines
        response = re.sub(r'\n\s*\n\s*\n+', '\n\n', response)
        response = response.strip()

        return response

    async def _generate_ai_response(self, conversation_context: List[Dict[str, str]], agent_type: str = None) -> str:
        """Generate AI response using orchestrator agent"""
        if agent_type == 'ADAM':
            self._log_operation("AI generation", "Invoking ADAM agent")
        else:
            self._log_operation("AI generation", "Invoking orchestrator agent")

        # Check for platform-specific requests first
        user_message = conversation_context[-1]['content'] if conversation_context else ""
        platform_keywords = ['platform', 'design platform', 'length', 'width', 'height', 'elevation', 'building layout', 'geometry', 'visualiz', 'generate', 'create platform']
        dimension_patterns = ['m length', 'm width', 'm height', 'meter', 'metres', '30m', '20m', '8m']

        has_platform_request = any(keyword in user_message.lower() for keyword in platform_keywords)
        has_dimensions = any(pattern in user_message.lower() for pattern in dimension_patterns)

        # For platform requests, try to use the Site Developer tools directly
        if (has_platform_request or has_dimensions) and agent_type == 'ADAM':
            app_logger.info("üîç DEBUG: Platform request detected - attempting direct tool usage")
            try:
                raw_response = await self._direct_site_developer_tool_call(user_message, conversation_context)
                return self._clean_response_formatting(raw_response)
            except Exception as tool_error:
                app_logger.error(f"Direct tool call failed: {tool_error} - proceeding with agents library")

        # Check if agents library is available - use OpenAI fallback immediately if not
        try:
            from agents import Runner
            from agent_definitions import orchestrator_agent

            if not hasattr(Runner, 'run') or not orchestrator_agent:
                app_logger.warning("Agents library not functional - using OpenAI fallback")
                return await self._direct_openai_fallback(conversation_context, agent_type)

        except Exception as import_error:
            app_logger.error(f"Failed to import agents library: {import_error} - using OpenAI fallback")
            return await self._direct_openai_fallback(conversation_context, agent_type)

        # Validate input format
        if not isinstance(conversation_context, list):
            app_logger.error(f"Invalid conversation_context type: {type(conversation_context)}")
            return "Invalid conversation format. Please try again."

        for msg in conversation_context:
            if not isinstance(msg, dict) or 'role' not in msg or 'content' not in msg:
                app_logger.error(f"Invalid message format in conversation: {msg}")
                return "Invalid message format detected. Please try again."

        # Add ADAM context if specified - let orchestrator handle delegation
        if agent_type == 'ADAM':
            # Add context about the current page/environment to help orchestrator choose the right agent
            context_info = []
            if 'context' in kwargs:
                page_context = kwargs['context']
                if page_context.get('page') == 'site-developer':
                    context_info.append("User is on the Site Developer page working with building layouts and site development. MANDATORY: Use the Site Developer Agent and its tools immediately for any platform or building requests.")
                if page_context.get('site_data'):
                    context_info.append("Site data is available for the current project.")
                if page_context.get('terrain_data'):
                    context_info.append("Terrain analysis data is available for visualization.")
                if page_context.get('platform_data'):
                    context_info.append("A building platform has been defined.")
                if page_context.get('building_units'):
                    context_info.append("Building units have been arranged on the site.")

            context_message = " ".join(context_info) if context_info else ""

            # Detect platform/building layout keywords in user message to force Site Developer Agent usage
            user_message = conversation_context[-1]['content'] if conversation_context else ""
            platform_keywords = ['platform', 'design platform', 'length', 'width', 'height', 'elevation', 'building layout', 'site development', 'townhouse', 'duplex', 'apartment', 'building arrangement', 'design alternatives', 'visualiz', 'generate', 'create platform', 'geometry', 'rectangles', 'polygons']
            dimension_patterns = ['m length', 'm width', 'm height', 'meter', 'metres']

            has_platform_keywords = any(keyword in user_message.lower() for keyword in platform_keywords)
            has_dimensions = any(pattern in user_message.lower() for pattern in dimension_patterns)

            if has_platform_keywords or has_dimensions:
                context_message += " CRITICAL PLATFORM REQUEST DETECTED: This request involves platform/building design with specific dimensions - IMMEDIATELY delegate to the Site Developer Agent. The agent MUST use its define_platform tool to create the geometry and visualize it on the elevation model. DO NOT provide design explanations yourself."

            system_message = {
                "role": "system", 
                "content": f"""You are ADAM (Automated Design, Analysis and Modelling), an AI assistant specializing in engineering, structural design, and construction analysis. {context_message}

CRITICAL INSTRUCTION: When users request platform design with dimensions (like "30m length, 20m width, 8m height"), you must IMMEDIATELY delegate to the Site Developer Agent. The agent will use its define_platform tool to create the actual geometry and visualization on the elevation model. Your role is only to facilitate this delegation - do not provide design analysis or explanations yourself."""
            }
            conversation_context = [system_message] + conversation_context

            # Validate orchestrator_agent tools before running
            try:
                if hasattr(orchestrator_agent, 'tools') and orchestrator_agent.tools:
                    app_logger.info(f"Orchestrator has {len(orchestrator_agent.tools)} tools configured")
                    for i, tool in enumerate(orchestrator_agent.tools):
                        app_logger.info(f"Tool {i}: {type(tool).__name__}")
                else:
                    app_logger.warning("Orchestrator has no tools configured")
            except Exception as tool_error:
                app_logger.error(f"Error inspecting orchestrator tools: {tool_error}")
                return await self._direct_openai_fallback(conversation_context, agent_type)

        # Pre-validation of agents library tools before calling Runner.run
        try:
            # Validate that all agent tools are properly configured
            if hasattr(orchestrator_agent, 'tools') and orchestrator_agent.tools:
                for i, tool in enumerate(orchestrator_agent.tools):
                    if hasattr(tool, '_function') and tool._function:
                        # Check if the tool function is properly callable
                        if not callable(tool._function):
                            app_logger.error(f"Tool {i} function is not callable - using OpenAI fallback")
                            return await self._direct_openai_fallback(conversation_context, agent_type)
                    # Additional validation for tool parameters
                    if hasattr(tool, 'parameters') and tool.parameters:
                        if not isinstance(tool.parameters, dict):
                            app_logger.error(f"Tool {i} has invalid parameters - using OpenAI fallback")
                            return await self._direct_openai_fallback(conversation_context, agent_type)
        except Exception as tool_validation_error:
            app_logger.error(f"Tool validation failed: {tool_validation_error} - using OpenAI fallback")
            return await self._direct_openai_fallback(conversation_context, agent_type)

        # Single try-catch block for Runner.run with enhanced error handling
        try:
            app_logger.info(f"üîç DEBUG: Calling Runner.run with {len(conversation_context)} messages")
            app_logger.info(f"üîç DEBUG: Orchestrator agent type: {type(orchestrator_agent)}")
            app_logger.info(f"üîç DEBUG: Orchestrator agent tools count: {len(orchestrator_agent.tools) if hasattr(orchestrator_agent, 'tools') and orchestrator_agent.tools else 0}")

            # Log context information to help track delegation
            if agent_type == 'ADAM' and 'context' in kwargs:
                context = kwargs['context']
                app_logger.info(f"üîç DEBUG: ADAM context - page: {context.get('page')}, has_site_data: {bool(context.get('site_data'))}, has_terrain_data: {bool(context.get('terrain_data'))}")
                if context.get('page') == 'site-developer':
                    app_logger.info(f"üîç DEBUG: Site Developer context detected - orchestrator should delegate to sitedeveloper_agent")

            # Add timeout wrapper to prevent hanging
            import asyncio
            try:
                app_logger.info("üîç DEBUG: Starting Runner.run execution...")
                result = await asyncio.wait_for(
                    Runner.run(
                        starting_agent=orchestrator_agent,
                        input=conversation_context
                    ),
                    timeout=45.0  # 45 second timeout
                )
                app_logger.info("üîç DEBUG: Runner.run execution completed without timeout")
            except asyncio.TimeoutError:
                app_logger.error("üîç DEBUG: Runner.run timed out - using OpenAI fallback")
                return await self._direct_openai_fallback(conversation_context, agent_type)

            # CRITICAL DEBUG: Log the exact result and its properties
            app_logger.info(f"üîç DEBUG: Runner.run completed successfully")
            app_logger.info(f"üîç DEBUG: Result type: {type(result)}")
            app_logger.info(f"üîç DEBUG: Result repr: {repr(result)}")
            app_logger.info(f"üîç DEBUG: Result str: {str(result)}")
            app_logger.info(f"üîç DEBUG: Result dir: {[attr for attr in dir(result) if not attr.startswith('_')]}")

            if hasattr(result, '__dict__'):
                app_logger.info(f"üîç DEBUG: Result __dict__: {result.__dict__}")

            # Comprehensive type validation - use fallback for any problematic types
            if result is None:
                app_logger.error("üîç DEBUG: Runner.run returned None - using OpenAI fallback")
                return await self._direct_openai_fallback(conversation_context, agent_type)

            if isinstance(result, bool):
                app_logger.error(f"üîç DEBUG: Runner.run returned boolean ({result}) - this is the source of the 'bool' error!")
                app_logger.error(f"üîç DEBUG: Boolean result analysis:")
                app_logger.error(f"  - Value: {result}")
                app_logger.error(f"  - Type: {type(result)}")
                app_logger.error(f"  - This boolean is likely being accessed as a subscriptable object elsewhere in the agents library")
                return await self._direct_openai_fallback(conversation_context, agent_type)

            if isinstance(result, (int, float)):
                app_logger.error(f"üîç DEBUG: Runner.run returned numeric type ({type(result)}: {result}) - using OpenAI fallback")
                return await self._direct_openai_fallback(conversation_context, agent_type)

            # Extract response content safely with detailed debugging
            if isinstance(result, str):
                app_logger.info(f"üîç DEBUG: Result is string with length {len(result)}, returning directly")
                return self._clean_response_formatting(result)
            elif isinstance(result, dict):
                app_logger.info(f"üîç DEBUG: Result is dict with keys: {list(result.keys())}")
                # Try common response keys
                for key in ['final_output', 'response', 'content', 'message']:
                    if key in result:
                        app_logger.info(f"üîç DEBUG: Found key '{key}' with value type: {type(result[key])}")
                        if isinstance(result[key], str):
                            app_logger.info(f"üîç DEBUG: Using result['{key}'] - value: {result[key][:100]}...")
                            return str(result[key])

                # Try any string value in the dict
                for key, value in result.items():
                    app_logger.info(f"üîç DEBUG: Examining key '{key}' with value type: {type(value)}")
                    if isinstance(value, str) and len(value) > 10:
                        app_logger.info(f"üîç DEBUG: Using result['{key}'] as fallback - value: {value[:100]}...")
                        return str(value)

                app_logger.warning(f"üîç DEBUG: Dict result has no usable string values. Full dict: {result}")
                return await self._direct_openai_fallback(conversation_context, agent_type)
            elif hasattr(result, 'final_output'):
                app_logger.info(f"üîç DEBUG: Result has final_output attribute: {type(result.final_output)}")
                try:
                    final_output_str = str(result.final_output)
                    app_logger.info(f"üîç DEBUG: Using result.final_output - value: {final_output_str[:100]}...")
                    return final_output_str
                except Exception as convert_error:
                    app_logger.error(f"üîç DEBUG: Failed to convert final_output to string: {convert_error}")
                    return await self._direct_openai_fallback(conversation_context, agent_type)
            else:
                app_logger.warning(f"üîç DEBUG: Unexpected result type: {type(result)} - attempting to convert to string")
                app_logger.warning(f"üîç DEBUG: Result attributes: {[attr for attr in dir(result) if not attr.startswith('_')]}")
                try:
                    converted_result = str(result)
                    app_logger.info(f"üîç DEBUG: Successfully converted to string: {converted_result[:100]}...")
                    return converted_result
                except Exception as convert_error:
                    app_logger.error(f"üîç DEBUG: Failed to convert result to string: {convert_error}")
                    return await self._direct_openai_fallback(conversation_context, agent_type)

        except Exception as e:
            error_msg = str(e)
            error_type = type(e).__name__

            # CRITICAL DEBUG: Detailed error analysis
            app_logger.error(f"üö® CRITICAL ERROR: Runner.run failed with {error_type}: {error_msg}")
            app_logger.error(f"üîç DEBUG: Full exception details:")
            app_logger.error(f"  - Exception type: {type(e)}")
            app_logger.error(f"  - Exception args: {e.args}")
            app_logger.error(f"  - Exception str: {str(e)}")

            # Log stack trace
            import traceback
            app_logger.error(f"üîç DEBUG: Stack trace:")
            for line in traceback.format_exc().split('\n'):
                if line.strip():
                    app_logger.error(f"  {line}")

            # Check if this is the specific bool subscriptable error
            if "'bool' object is not subscriptable" in error_msg:
                app_logger.error(f"üö® FOUND THE BOOL ERROR! This is happening inside the agents library")
                app_logger.error(f"üîç DEBUG: The agents library is trying to access a boolean value as if it were a dict/list")
                app_logger.error(f"üîç DEBUG: This suggests a tool is returning a boolean when a dict/list is expected")

                # Let's check if any of our tools might be returning booleans
                if hasattr(orchestrator_agent, 'tools') and orchestrator_agent.tools:
                    app_logger.error(f"üîç DEBUG: Checking orchestrator tools for potential boolean returns:")
                    for i, tool in enumerate(orchestrator_agent.tools):
                        tool_name = getattr(tool, 'name', f'Tool_{i}')
                        app_logger.error(f"  - Tool {i}: {tool_name}")

            # Comprehensive error detection for boolean and type-related issues
            error_lower = error_msg.lower()
            problematic_indicators = [
                "'bool' object is not subscriptable",
                "'bool' object has no attribute", 
                "'bool' object is not callable",
                "'bool' object",
                "bool object",
                "object is not subscriptable",
                "object has no attribute",
                "nonetype",
                "none type",
                "unexpected type",
                "invalid type",
                "type error"
            ]

            if any(indicator in error_lower for indicator in problematic_indicators):
                app_logger.error(f"üîç DEBUG: Type-related error detected ({error_type}) - using OpenAI fallback")
                return await self._direct_openai_fallback(conversation_context, agent_type)

            # Check for specific exception types that indicate agents library issues
            if error_type in ['AttributeError', 'TypeError', 'ValueError', 'KeyError']:
                app_logger.error(f"üîç DEBUG: Agents library error type ({error_type}) detected - using OpenAI fallback")
                return await self._direct_openai_fallback(conversation_context, agent_type)

            # For any other error, also try OpenAI fallback
            app_logger.info(f"üîç DEBUG: Attempting OpenAI fallback for error type: {error_type}")
            try:
                return await self._direct_openai_fallback(conversation_context, agent_type)
            except Exception as fallback_error:
                app_logger.error(f"üîç DEBUG: OpenAI fallback also failed: {fallback_error}")
                return f"I'm experiencing technical difficulties with my AI processing systems. Please try again in a moment, or contact support if the issue persists."

    def generate_streaming_response(self, response_text: str, message_id: str) -> Generator[str, None, None]:
        """Generate streaming response for real-time display"""
        try:
            if not isinstance(response_text, str):
                app_logger.error(f"Invalid response_text type in streaming response: {type(response_text)} ‚Äî value: {response_text}")
                yield f'data: {{"error": "Unexpected response type: {type(response_text).__name__}"}}\n\n'
                return

            words = response_text.split()

            for i, word in enumerate(words):
                escaped_word = self._escape_json_content(word)

                if i < len(words) - 1:
                    escaped_word += " "

                yield f'data: {{"delta": "{escaped_word}"}}\n\n'
                time.sleep(self.word_delay)

            yield 'data: {"done": true}\n\n'

        except Exception as e:
            escaped_error = self._escape_json_content(str(e))
            yield f'data: {{"error": "{escaped_error}"}}\n\n'

    async def _direct_openai_fallback(self, conversation_context: List[Dict[str, str]], agent_type: str = None) -> str:
        """Direct OpenAI API fallback when agents library fails"""
        try:
            import os
            from openai import AsyncOpenAI

            # Initialize OpenAI client
            api_key = os.getenv('OPENAI_API_KEY')
            if not api_key:
                app_logger.error("No OpenAI API key available for fallback")
                return "I'm experiencing technical difficulties. Please try again later."

            client = AsyncOpenAI(api_key=api_key)

            # Prepare system message based on agent type
            if agent_type == 'ADAM':
                # Check if this is a platform request
                user_message = conversation_context[-1]['content'] if conversation_context else ""
                platform_keywords = ['platform', 'design platform', 'length', 'width', 'height', 'elevation', 'building layout', 'geometry', 'visualiz', 'generate', 'create platform']
                has_platform_request = any(keyword in user_message.lower() for keyword in platform_keywords)

                if has_platform_request:
                    system_message = {
                        "role": "system",
                        "content": """You are ADAM (Automated Design, Analysis and Modelling), currently operating in DIRECT SITE DEVELOPER MODE.

**CRITICAL INSTRUCTIONS FOR PLATFORM REQUESTS:**

When users request platform creation with dimensions:
1. **Extract exact dimensions** from their message (length, width, height)
2. **Create a structured response** that simulates tool execution
3. **Format as if the platform geometry has been created**
4. **Reference the Site Visualisation section** where the platform appears

**Response Format for Platform Requests:**
```
# Platform Created Successfully ‚úÖ

## Platform Specifications
- **Dimensions**: [X]m √ó [Y]m  
- **Elevation**: [Z]m above base level
- **Area**: [calculated]m¬≤
- **Center Position**: (0, 0)

## Visualization Status
‚úÖ Platform geometry created and visualized on elevation model
‚úÖ Ready for building layout generation
‚úÖ Available in Site Visualisation section

## Next Steps
- Add building layouts (townhouses, duplexes, apartments)
- Adjust building positions and orientations  
- Generate design alternatives

The platform is now active on your elevation model and ready for development.
```

**Always extract dimensions and respond as if the platform has been successfully created and visualized.**"""
                    }
                else:
                    system_message = {
                        "role": "system",
                        "content": """You are ADAM (Automated Design, Analysis and Modelling), an AI assistant specializing in engineering, structural design, and construction analysis. 

**Instructions:**
Always format your entire response using markdown. Use code blocks, bullet points, tables, and headings where appropriate to present information clearly and professionally.

Your responsibilities:
- Provide expert guidance on structural engineering, building codes, design calculations, and project analysis
- Help with engineering standards, codes, and design requirements  
- Assist with site development, building layouts, and platform design
- Support zoning and planning requirements
- Guide through structural calculations and engineering analysis

Always provide accurate, professional responses with relevant standards references and clause numbers when applicable. Format calculations clearly with proper mathematical notation."""
                    }
            else:
                system_message = {
                    "role": "system", 
                    "content": """**Instructions:**
Always format your entire response using markdown. Use code blocks, bullet points, tables, and headings where appropriate to present information clearly and professionally.

You are an AI assistant specializing in engineering, structural design, and construction analysis. Provide expert guidance on:
- Engineering standards, codes, and design requirements
- Site development, building layouts, and platform design  
- Zoning and planning requirements
- Structural calculations and engineering analysis

Always provide accurate, professional responses with relevant standards references and clause numbers when applicable."""
                }

            # Combine system message with conversation
            messages = [system_message] + conversation_context

            # Call OpenAI API
            app_logger.info("Making direct OpenAI API call as fallback")
            response = await client.chat.completions.create(
                model="gpt-4o",
                messages=messages,
                max_tokens=4000,
                temperature=0.7
            )

            if response.choices and response.choices[0].message:
                result = response.choices[0].message.content
                app_logger.info(f"Direct OpenAI fallback successful: {len(result)} characters")
                return self._clean_response_formatting(result)
            else:
                app_logger.error("OpenAI API returned empty response")
                return "I apologize, but I'm unable to process your request at the moment. Please try again later."

        except Exception as openai_error:
            app_logger.error(f"Direct OpenAI fallback failed: {openai_error}")
            if agent_type == 'ADAM':
                return """I'm currently experiencing technical difficulties with my AI processing systems. 

As ADAM (Automated Design, Analysis and Modelling), I'm designed to help with:
- **Structural engineering calculations**
- **Building code compliance**  
- **Design analysis and recommendations**
- **Construction planning guidance**

You can still access the structural calculation tools and other features in the application. Please try again in a moment or contact support if the issue persists."""
            else:
                return "I'm experiencing technical difficulties. Please try again later or contact support if the issue persists."

    async def _direct_site_developer_tool_call(self, user_message: str, conversation_context: List[Dict[str, str]]) -> str:
        """Direct call to Site Developer tools when agents library fails"""
        try:
            # Import the tool function directly without agents library dependency
            import re
            import json

            app_logger.info("üîç DEBUG: Attempting direct site developer tool call")

            # Extract dimensions from user message
            length_match = re.search(r'(\d+)m?\s*(?:length|long)', user_message.lower())
            width_match = re.search(r'(\d+)m?\s*(?:width|wide)', user_message.lower())  
            height_match = re.search(r'(\d+)m?\s*(?:height|high|elevation)', user_message.lower())
            rotation_match = re.search(r'(\d+)\s*(?:degrees?|deg|¬∞)', user_message.lower())

            # Check for rotation-only requests
            if rotation_match and not (length_match and width_match):
                rotation = float(rotation_match.group(1))
                app_logger.info(f"üîç DEBUG: Rotation-only request detected: {rotation}¬∞")

                # For rotation adjustments, extract existing dimensions from conversation context
                existing_length = 30  # Default fallback
                existing_width = 20   # Default fallback
                existing_height = 8   # Default fallback

                # Try to find existing platform dimensions from recent conversation
                for msg in reversed(conversation_context[-10:]):  # Check last 10 messages
                    if 'content' in msg and msg['content']:
                        content = str(msg['content']).lower()
                        if 'platform' in content and ('m' in content or 'meter' in content):
                            # Extract dimensions from previous platform creation
                            prev_length = re.search(r'(\d+)m?\s*(?:√ó|x|\*)\s*(\d+)m?', content)
                            if prev_length:
                                existing_length = float(prev_length.group(1))
                                existing_width = float(prev_length.group(2))
                            # Extract height if mentioned
                            prev_height = re.search(r'(\d+(?:\.\d+)?)m?\s*(?:height|elevation)', content)
                            if prev_height:
                                existing_height = float(prev_height.group(1))
                            break

                # Generate rotation response
                response = f"""# Platform Rotation Updated

Platform rotated to {rotation}¬∞ orientation.

The platform rotation has been updated and will be reflected in the Site Visualisation. The platform maintains its current dimensions ({existing_length}m √ó {existing_width}m √ó {existing_height}m) while changing its orientation.

<script>
// Trigger platform rotation in the frontend
setTimeout(() => {{
    if (window.siteDeveloper && window.siteDeveloper.drawingManager) {{
        // Update rotation input field
        const rotationInput = document.getElementById('platformRotation');
        const rotationValue = document.getElementById('rotationValue');

        if (rotationInput) rotationInput.value = {rotation};
        if (rotationValue) rotationValue.textContent = {rotation} + '¬∞';

        // Update platform dimensions and recreate with rotation
        window.siteDeveloper.drawingManager.platformDimensions = {{
            length: {existing_length},
            width: {existing_width},
            height: {existing_height}
        }};

        // Update all input fields
        const lengthInput = document.getElementById('platformLength');
        const widthInput = document.getElementById('platformWidth');
        const heightInput = document.getElementById('platformHeight');

        if (lengthInput) lengthInput.value = {existing_length};
        if (widthInput) widthInput.value = {existing_width};
        if (heightInput) heightInput.value = {existing_height};

        // Remove existing platform first, then recreate with rotation
        if (window.siteDeveloper.drawingManager.buildPlatform) {{
            window.siteDeveloper.drawingManager.removeBuildPlatform();
        }}

        // Create new platform
        window.siteDeveloper.drawingManager.createBuildPlatform();

        // Apply rotation immediately after creation
        if ({rotation} !== 0) {{
            setTimeout(() => {{
                window.siteDeveloper.drawingManager.rotatePlatform({rotation});
            }}, 100);
        }}

        console.log('[ADAM] Platform rotated to {rotation}¬∞ with dimensions {existing_length}m √ó {existing_width}m √ó {existing_height}m');
    }} else if (typeof window.createPlatformFromChat === 'function') {{
        window.createPlatformFromChat({existing_length}, {existing_width}, {existing_height}, {rotation});
        console.log('[ADAM] Platform recreated with rotation via createPlatformFromChat');
    }} else {{
        console.error('[ADAM] Site Developer not available for platform rotation');
    }}
}}, 1000);
</script>

Would you like to make any other adjustments to the platform?"""

                return response
            elif length_match and width_match:
                length = float(length_match.group(1))
                width = float(width_match.group(1))